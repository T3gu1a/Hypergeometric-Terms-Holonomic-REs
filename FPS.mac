/************************** FPS computations and m-fold Hypergeometric term solutions of linear difference equations *********************************/
nn:n$
fexpr:f$
LL:L$
funf: fun$
FF: F$
Hde_step1: Hde_step$
zz: z$
kill(fun,F,Hde_step,z,f)$

/*kill(fun,RE,expr,L,L1,L2,func,law,Mat,Comp,M,N)$*/
/* Some need packages so that the program can work with any maxima's version */

load("basic")$  /*to be able to use 'pop' */

load ("functs")$ /* to use lcm */




/**************************************Funy code **************************************/

randompoly(z):=block([N,M,P],
    N: random(11),
    M: -random(11),
    P:0,
    for i:M thru N do P: P+(-random(2)*random(27)+random(2)*random(27))*z^i,
    P
)$


/* Variable to avoid some warning messages from Taylor expansion used */

taylordepth:50$


/* Default maximum order of DEs*/

Nmax: 6$

testholonomic(%f,%z):=block([expr],
    expr: expand(denom(ratsimp(diff(%f,%z)))),
    lfreeof([cos,sin,log,asin,asinh,acos,acosh],expr)
)$
/********************************************************* CODE TO FIND THE HOLONOMIC DE ***************************************************************/


/*main program*/
HolonomicDE(fun,F,[Hde_step]):=catch(block([Itop,Itv,de_step,f,z,df,N,Nb,Coef,Eq,Basis,Comp,Term,Mat,g],
    if(length(Hde_step)>2 or atom(F)) then(
        print("Wrong input(s)"),
        throw(false)
    ),
    Itv: args(F),
    Itop: op(F),
    if(not (length(Itv)=1 and atom(Itv[1]) and atom(Itop))) then (
        print("Wrong input(s)"),
        throw(false)
    ),
    if(emptyp(Hde_step)) then de_step: 1
    else de_step: Hde_step[1],
    if(not(integerp(de_step)) or de_step < 1) then (
        print("The last argument must be a positive integer"),
        throw(false)
    ),
    g:trigsimp(trigexpand(fun)),
    algebraic:true,
    z:first(F),
    if(ratfunp(g,[z])) then f:radcan(fun)
    else f:radcan(g),
    if(not testholonomic(f,z)) then throw(HolonomicDE2(g,F,de_step)),
    algebraic:false,
    if(f=0) then F=0
    else(
        N:0,
        algebraic:true,
        df:expand(f),
        Term:colTerm(df,"+"),
        [Basis,Comp]:augBasis(Term,z),
        Mat:matrix(Comp),
        Nb:length(Basis),
        Coef:[],
        if(Nmax<6 or integerp(Nmax)=false) then Nmax:6,
        while Coef=[] and N<Nmax do (
            N:N+1,
            df:expand(radcan(diff(df,z,de_step))),
            Term:colTerm(df,"+"),
            [Basis,Comp]:basisComp(Basis,Term,z),
            Mat: adapt(Mat,Comp),
            if(Nb=length(Comp)) then Coef:holoSolve(Mat,N)
            else Nb:length(Comp)
        ),
        algebraic:false,
        if(length(Coef)>0) then
        (
                Eq: 'diff(F,z,de_step*N)+sum(Coef[i+1]*'diff(F,z,de_step*i),i,0,N-1),
                num(xthru(Eq))=0
        )
        else if(f-radcan(g)#0) then HolonomicDE2(g,F,de_step)
    )
))$

/* program used to check rationality */ 

expr1: expr$
kill(expr)$

ratfunp(expr,L):=block([r],
  r: ratsimp(expr),
  polynomialp(num(r),L) and polynomialp(denom(r),L)
)$

/* program used to colect term in an expansion*/

colTerm(func,law):=block([L,T],
    if(atom(func)) then [func]
    else (
        L:args(func),
        T:apply(law,L),
        if(T/func=1) then L
        else [func]
    )
)$

/* program used to adapt the matrix of a given expression*/
Mat1: Mat$
kill(Mat)$

adapt(Mat,Comp):=block([Ncol,Nrow,Ncomp,dN,M,zcol],
    Ncol:length(transpose(Mat)),
    Nrow:length(Mat),
    Ncomp:length(Comp),
    dN:Ncomp-Ncol,
    M:Mat,
    if(dN>0) then (
        Zcol:makelist(0,i,1,Nrow),
        for i:1 thru dN do M: addcol(M,Zcol)
    ),
    addrow(M,Comp)
)$

/* program used to find component and extend the basis  */

L11: L1$
L22: L2$
kill(L1,L2)$

basisComp(L1,L2,z):=block([Basis,Basis1,Term,comp,tmp,remL,qtmp,Comp,T1,T2],
    Basis1:L1,
    Term:L2,
    Basis:[],
    Comp:[],
    while Basis1#[] do (
        remL:[],
        tmp:Basis1[1],
        comp:0,
        if(Term#[]) then
            for j:1 thru length(Term) do (
                qtmp:Term[j]/tmp,
                if(ratfunp(qtmp,[z])=true) then (
                    comp: comp+qtmp,
                    remL: endcons(Term[j],remL)
                )
            ),
        Basis: endcons(tmp, Basis),
        Comp: endcons(comp, Comp),
        Term: sublist(Term, lambda([v], not(member(v,remL)))),
        Basis1: sublist(Basis1, lambda([v], v#tmp))
    ),
    [T1,T2]:augBasis(Term,z),
    Basis:append(Basis,T1),
    Comp:append(Comp,T2),
    [Basis,Comp]
)$

/* program used to recognize new element for the basis */

augBasis(L,z):=block([Term,Basis,Comp,qtmp,tmp,remL],
     Term: L,
     Basis: [],
     Comp:[],
     while Term#[] do (                                                                                                
        remL: [Term[1]],
        tmp: Term[1],
        if(length(Term)>1) then
            for j: 2 thru length(Term) do (
                qtmp:Term[j]/tmp,
                if(ratfunp(qtmp,[z])=true) then (
                    tmp:  tmp+Term[j],
                    remL: endcons(Term[j], remL)
                )
            ),
        Basis: endcons(tmp, Basis),
        Comp: endcons(1, Comp),
        Term: sublist(Term, lambda([v], not(member(v,remL))))
     ),
     [Basis,Comp]
)$

/* program used for solving the resulting system */

MM: M$
NN: N$
kill(M,N)$

holoSolve(M,N):=block([Mat,xv,b,Alist,Sol],
        b:transpose(-row(M,N+1)),
        Alist:makelist(concat('%A,i),i,0,N-1),                                                                                                                             
        xv: transpose(matrix(Alist)),
        Mat:transpose(submatrix(N+1,M)),
        linsolvewarn:false,
        Sol:xreduce('append,args(Mat.xv-b)),
        Sol:linsolve(Sol,Alist),
        linsolvewarn:true,
        Sol:map(lambda([v],rhs(v)),Sol),
        map(lambda([v],factor(num(v))/factor(denom(v))),Sol)
)$

DE11: DE1$
DE22: DE2$
kill(DE1,DE2)$

CompatibleDE(DE1,DE2,F):=block([z,d1,d2],
    if(not(atom(DE1)) and not(atom(DE2)) and not(atom(F)) and not(freeof(F,DE1)) and not(freeof(F,DE2))) then (
        z: first(F),
        d1: derivdegree(DE1,F,z),
        d2: derivdegree(DE2,F,z),
        if(d1>d2) then substruleDE(DE2,DE1,d2,d1,F,z)
        else substruleDE(DE1,DE2,d1,d2,F,z)
    )
)$

substruleDE(DE11,DE22,d11,d22,F,z):=block([rule0,listrules,DE,j],
    rule0: solve(DE11,diff(F,z,d11))[1],
    DE: DE22,
    listrules: makelist(diff(rule0,z,j),j,1,d22-d11),
    for j: length(listrules) thru 1 step -1 do 
        DE: subst(listrules[j],DE),
    DE: lhs(expand(subst(rule0,DE))),
    DE: sum(factor(coeff(DE,diff(F,z,j)))*diff(F,z,j),j,0,d1),
    if(DE=0) then (
        print("The two differential equations are compatible"),
        true
    )
    else (
        print("The two differential equations are not compatible"),
        false
    )
)$


HolonomicDE2(fun,F,[Hde_step]):=catch(block([Itv,Itop,de_step,f,z,A0,flag,N,I,Coef,Eq,Eqs,Sumds,S,del,tmp,polfact,Lflag,isol],
    if(length(Hde_step)>2 or atom(F)) then(
        print("Wrong input(s)"),
        throw(false)
    ),
    Itv: args(F),
    Itop: op(F),
    if(not (length(Itv)=1 and atom(Itv[1]) and atom(Itop))) then (
        print("Wrong input(s)"),
        throw(false)
    ),
    if(emptyp(Hde_step)) then de_step: 1
    else de_step: Hde_step[1],
    if(not(integerp(de_step)) or de_step < 1) then (
        print("The last argument must be a positive integer"),
        throw(false)
    ),
    f: radcan(fun),
    if(not testholonomic(f,z)) then throw(false),
    z: first(F),
    if(f=0) then F=0
    else(
        A0:diff(f,z,de_step)/f,  
        if(ratfunp(A0,[z])=true) then                                                                                                   /*1*/                    
            num(ratsimp('diff(F,z,de_step)-A0*F))=0                                                                                                                           
        else (                                                                                                                          /*2*/
            if(Nmax<4 or integerp(Nmax)=false) then Nmax:4,
            flag: false,
            N: 2,
            while N<=Nmax and flag=false do (                                                                                           /*3*/                                              
                     I: makelist(i,i,0,N-1),                                                                                                                              
                     Coef: create_list(A[i],i,I),
                     var: append(Coef,[z]),  
                     algebraic:true,                                                                                        
                     Eq: expand(ratsimp(diff(f,z,N*de_step))+sum(ratsimp(Coef[i+1]*diff(f,z,i*de_step)),i,0,N-1)),                      /*4*/
                     S: args(Eq),
                     algebraic:false,
                     Sumds: [],
                     while S#[] do (                                                                                                    /*5*/
                        del: [S[1]],
                        tmp: S[1],
                        if(length(S)>1) then
                            for j: 2 thru length(S) do
                                if(ratfunp(S[j]/S[1],var)=true) then (
                                    tmp: tmp + S[j],
                                    del: endcons(S[j], del)
                                ),
                        Sumds: endcons(tmp, Sumds),
                        S: sublist(S, lambda([v], not(member(v,del))))
                     ), 
                    isol: sublist(Sumds, lambda([v], lfreeof(Coef,v))),
                    if(isol=[]) then(                                                                                                    /*6*/
                        Sumds: map(lambda([v],num(factor(v))),Sumds),
                        logexpand: all,
                        Eqs: [],
                        for i: 1 thru length(Sumds) do 
                        if(polynomialp(Sumds[i],var)=true or member(Sumds[i],Coef)=true) then Eqs: endcons(Sumds[i],Eqs)                 /*7*/
                        else( 
                             factSumd:exp(args(log(Sumds[i]))),
                             polfact: sublist(factSumd, lambda([v], (polynomialp(v,var) or member(v,Coef)) and not(constantp(v)))),
                             Eqs: append(Eqs, polfact)
                        ), 
                        logexpand:true,
                        linsolvewarn:false,
                        Eqs: sublist(Eqs, lambda([v], not(polynomialp(v,[z])))), 
                        Sol: linsolve(Eqs,Coef), 
                        linsolvewarn:true, 
                        if(Sol#[]) then (                                            
                            Coef: map(lambda([v],rhs(v)),Sol),                                                            
                            Lflag: map(lambda([v],ratfunp(v,[z])), Coef),                                                   
                            flag: apply("and", Lflag),
                            if(flag=false) then N: N+1 
                        )
                        else N: N+1
                    )                                                                  
                    else N: N+1                                                         
            ),                                                                                                                
            if(N>Nmax) then flag                                                                                                          /*8*/                                               
            else (                                                                                                               
                Eq: 'diff(F,z,N*de_step)+sum(Coef[i+1]*'diff(F,z,i*de_step),i,0,N-1),                  
                num(ratsimp(Eq))=0  
           )                                                                     
        )
    )
))$



/*********************************************** QUADRATIC HOMOGENEOUS DE *****************************************************************/

QNmax: 21$

kk: k$
kill(k)$

ordertocouple(k):=block([r,N],
    r: floor(sqrt(2*k + 0.25)-0.5),
    N: r*(r+1)/2,
    if(N = k) then [r,r]
    else [r+1,k-N]
)$

delta2diff(expr,z,n):=block([couple],
    if(integerp(n) and n>0) then (
        couple: sublist(ordertocouple(n) - 2, lambda([v], v>-1)),
        lprod(map(lambda([v], diff(expr,z,v)),couple))
    )
)$

QDE(fun,F,[HI]):=catch(block([f,z,A0,flag,N,I,V,Coef,Eq,Eqs,Sumds,S,D,tmp,polfact,Lflag,isol,R,denCoef],
    if(not(emptyp(HI)) and HI[1]=Inhomogeneous) then throw(IQDE(fun,F)),
    z: first(F),
    algebraic:true,
    f: radcan(trigsimp(trigexpand(fun))),
    if(ratfunp(f,[z])) then f:radcan(fun),
    algebraic:false,
    if(f=0) then F=0
    else(
        A0:delta2diff(f,z,3)/f,  
        if(ratfunp(A0,[z])=true) then                                                                                                   /*1*/                    
            num(xthru(delta2diff(F,z,3)-A0*F))=0                                                                                                                           
        else (                                                                                                                          /*2*/
            if(QNmax<18 or integerp(QNmax)=false) then QNmax:18,
            flag: false,
            N: 4,
            while N<=QNmax and flag=false do (                                                                                           /*3*/ 
                     I: makelist(i,i,0,N-3),                                                                                                                              
                     Coef: create_list(A[i],i,I),
                     V: append(Coef,[z]),  
                     algebraic:true,                                                                                        
                     Eq: expand(num(radcan(trigsimp(delta2diff(f,z,N)+sum(Coef[i-1]*delta2diff(f,z,i),i,2,N-1))))),                     /*4*/
                     if(Eq=0) then throw(F=0),
                     S: args(Eq),
                     Sumds: [],
                     isol: false,
                     while S#[] and isol=false do (                                                                                      /*5*/
                        D: [S[1]],
                        tmp: S[1],
                        if(length(S)>1) then
                            for j: 2 thru length(S) do
                                if(ratfunp(S[j]/S[1],V)=true) then (
                                    tmp: tmp + S[j],
                                    D: endcons(S[j], D)
                                ),
                        Sumds: endcons(tmp, Sumds), 
                        isol: lfreeof(Coef,tmp),
                        S: sublist(S, lambda([v], not(member(v,D))))
                     ), 
                    algebraic:false,
                    if(isol=false) then(                                                                                                    /*6*/
                        Sumds: map(lambda([v],num(factor(v))),Sumds),
                        logexpand: all,
                        Eqs: [],
                        for i: 1 thru length(Sumds) do 
                        if(polynomialp(Sumds[i],V)=true or member(Sumds[i],Coef)=true) then Eqs: endcons(Sumds[i],Eqs)                  /*7*/
                        else( 
                             factSumd:exp(args(log(Sumds[i]))),
                             polfact: sublist(factSumd, lambda([v], (polynomialp(v,V) or member(v,Coef)) and not(constantp(v)))),
                             Eqs: append(Eqs, polfact)
                        ), 
                        logexpand:true,
                        linsolvewarn:false,
                        Eqs: sublist(Eqs, lambda([v], not(polynomialp(v,[z])))), 
                        Sol: linsolve(Eqs,Coef),
                        linsolvewarn:true, 
                        if(Sol#[]) then (        
                            R: map(lambda([v],v=1),%rnum_list),
                            Sol: subst(R,Sol),
                            Coef: map(lambda([v],factor(rhs(v))),Sol),
                            flag: true
                        )
                        else N: N+1
                    )                                                                  
                    else N: N+1                                                         
            ),           
            if(N>QNmax) then flag                                                                                                          /*8*/                                               
            else (
                denCoef: lcm(map(denom, Coef)),
                Coef: map(lambda([v], xthru(denCoef*v)),Coef),
                denCoef*delta2diff(F,z,N)+sum(Coef[i-1]*delta2diff(F,z,i),i,2,N-1)=0
           )                                                                     
        )
    )
))$


IQDE(fun,F):=catch(block([f,z,A0,flag,N,I,V,Coef,Eq,Eqs,Sumds,S,D,tmp,polfact,Lflag,isol,R,denCoef],
    algebraic:true,
    f: radcan(trigsimp(trigexpand(fun))),
    algebraic:false,
    z: first(F),
    if(f=0) then F=0
    else(
        A0:delta2diff(f,z,3)/f,  
        if(ratfunp(A0,[z])=true) then                                                                                                   /*1*/                    
            num(xthru(delta2diff(F,z,3)-A0*F))=0                                                                                                                           
        else (                                                                                                                          /*2*/
            if(QNmax<18 or integerp(QNmax)=false) then QNmax:18,
            flag: false,
            N: 4,
            while N<=QNmax and flag=false do (                                                                                           /*3*/ 
                     I: makelist(i,i,1,N-1),                                                                                                                              
                     Coef: create_list(A[i],i,I),
                     V: append(Coef,[z]),  
                     algebraic:true,                                                                                        
                     Eq: expand(num(radcan(trigsimp(delta2diff(f,z,N)+sum(Coef[i]*delta2diff(f,z,i),i,1,N-1))))),                     /*4*/
                     if(Eq=0) then throw(F=0),
                     S: args(Eq),
                     algebraic:false,
                     Sumds: [],
                     while S#[] do (                                                                                                     /*5*/
                        D: [S[1]],
                        tmp: S[1],
                        if(length(S)>1) then
                            for j: 2 thru length(S) do
                                if(ratfunp(S[j]/S[1],V)=true) then (
                                    tmp: tmp + S[j],
                                    D: endcons(S[j], D)
                                ),
                        Sumds: endcons(tmp, Sumds),
                        S: sublist(S, lambda([v], not(member(v,D))))
                     ), 
                    isol: sublist(Sumds, lambda([v], lfreeof(Coef,v))),
                    if(isol=[]) then(                                                                                                    /*6*/
                        Sumds: map(lambda([v],num(factor(v))),Sumds),
                        logexpand: all,
                        Eqs: [],
                        for i: 1 thru length(Sumds) do 
                        if(polynomialp(Sumds[i],V)=true or member(Sumds[i],Coef)=true) then Eqs: endcons(Sumds[i],Eqs)                  /*7*/
                        else( 
                             factSumd:exp(args(log(Sumds[i]))),
                             polfact: sublist(factSumd, lambda([v], (polynomialp(v,V) or member(v,Coef)) and not(constantp(v)))),
                             Eqs: append(Eqs, polfact)
                        ), 
                        logexpand:true,
                        linsolvewarn:false,
                        Eqs: sublist(Eqs, lambda([v], not(polynomialp(v,[z])))), 
                        Sol: linsolve(Eqs,Coef),
                        linsolvewarn:true, 
                        if(Sol#[]) then (        
                            R: map(lambda([v],v=1),%rnum_list),
                            Sol: subst(R,Sol),
                            Coef: map(lambda([v],factor(rhs(v))),Sol),
                            flag: true
                        )
                        else N: N+1
                    )                                                                  
                    else N: N+1                                                         
            ),           
            if(N>QNmax) then flag                                                                                                          /*8*/                                               
            else (
                denCoef: lcm(map(denom, Coef)),
                Coef: map(lambda([v], xthru(denCoef*v)),Coef),
                denCoef*delta2diff(F,z,N)+sum(Coef[i]*delta2diff(F,z,i),i,1,N-1)=0
           )                                                                     
        )
    )
))$

/***********************************************CODE TO DEDUCE THE RE FROM THE DE ***********************************************************/ 

rec11:rec1$
rec22:rec2$
k00: k0$
kill(k0,rec1,rec2)$

DECauchyprod(rec1,rec2,n,k,k0):=block([],
    indicecauchy: indicecauchy + 1,
    sum(subst(k,n,rec1)*subst(n-k,n,rec2),k,k0,n-k0)
)$

inttorec(jj,a):=block([n],
    n: first(a),
    pochhammer(n+1,jj)*subst(n+jj,n,a)
)$

kill(term,F,a)$

Qrectermfun(term,F,a,k0):=block([z,n,j,q,mterm,Ldiff,Lrec,zpow,coef,Cauchyterm,i,k,L],
    if(constantp(term)) then term
    else(
        z: first(F),
        n: first(a),
        mterm: term,
        j: derivdegree(term,F,z),
        q: hipow(term,'diff(F,z,j)),
        Ldiff: [],
        while(not polynomialp(mterm,[z])) do (
            Ldiff: append(Ldiff,makelist(j,q)),
            mterm: xthru(mterm/'diff(F,z,j)^q),
            j: derivdegree(mterm,F,z),
            q: hipow(mterm,'diff(F,z,j))
        ),
        zpow: hipow(mterm,z),
        coef: coeff(mterm,z,zpow),
        Lrec: map(lambda([v],inttorec(v,a)),Ldiff),
        Cauchyterm: Lrec[1],
        L: makelist(concat(k,i),i,indicecauchy,indicecauchy+length(Lrec)-1),
        for i:2 thru length(Lrec) do (
            Cauchyterm: DECauchyprod(Cauchyterm,Lrec[i],n,k,k0),
            Cauchyterm: subst(L[i-1],k,Cauchyterm)
        ),
        coef*subst(n-zpow,n,Cauchyterm)
    )
)$

DEDE:DE$
kill(DE)$

QDEtoRE(DE,F,a,k0):=block([de,terms,rec,RE,aterm,i],
    indicecauchy:1,
    de: lhs(expand(DE)),
    if(freeof("+",de)) then terms: [de]
    else terms: args(de),
    rec: map(lambda([v],Qrectermfun(v,F,a,k0)),terms),
    RE: apply("+",rec),
    aterm: sublist(listofvars(RE), lambda([v], not atom(v))),
    aterm: sort(sublist(aterm, lambda([v], is(equal(op(a),op(v)))))),
    if(length(aterm)<2) then RE=0
    else (
        for i: 1 thru length(aterm) do RE: map(factor, collectterms(RE,aterm[i])),
        RE=0
    )
)$


UQrectermfun(term,F,a,k0):=block([z,n,j,q,mterm,Ldiff,Lrec,zpow,coef,Cauchyterm,i,k,L],
    if(constantp(term)) then term
    else(
        z: first(F),
        n: first(a),
        mterm: term,
        j: derivdegree(term,F,z),
        q: hipow(term,'diff(F,z,j)),
        Ldiff: [],
        while(not polynomialp(mterm,[z])) do (
            Ldiff: append(Ldiff,makelist(j,q)),
            mterm: xthru(mterm/'diff(F,z,j)^q),
            j: derivdegree(mterm,F,z),
            q: hipow(mterm,'diff(F,z,j))
        ),
        zpow: hipow(mterm,z),
        coef: coeff(mterm,z,zpow),
        Lrec: map(lambda([v],inttorec(v,a)),Ldiff),
        Cauchyterm: Lrec[1],
        for i:2 thru length(Lrec) do Cauchyterm: DECauchyprod(Cauchyterm,Lrec[i],n,k,k0),
        coef*subst(n-zpow,n,Cauchyterm)
    )
)$

UQDEtoRE(DE,F,a,k0):=block([de,terms,rec,RE,aterm,i],
    de: lhs(expand(DE)),
    if(freeof("+",de)) then terms: [de]
    else terms: args(de),
    rec: map(lambda([v],UQrectermfun(v,F,a,k0)),terms),
    RE: intosum(apply("+",rec)),
    aterm: sublist(listofvars(RE), lambda([v], not atom(v))),
    aterm: sort(sublist(aterm, lambda([v], is(equal(op(a),op(v)))))),
    if(length(aterm)<2) then RE=0
    else (
        for i: 1 thru length(aterm) do RE: map(factor, collectterms(RE,aterm[i])),
        RE=0
    )
)$

/******************************************************************************************************************/

poch(n,k):=block([],
    if k=0 then 1
    else binomial(n+k-1,k)*k!
)$

/* Here the DE is known, and it is in DE */
rectermfun(term,F,a):=block([z,n,j,mterm,zpow,coef],
    z: first(F),
    n: first(a),
    j: derivdegree(term,F,z),
    mterm: xthru(term/'diff(F,z,j)),
    zpow: hipow(mterm,z),
    coef: coeff(mterm,z,zpow),
    coef*pochhammer(n+1-zpow, j)*subst(n+j-zpow,n,a)
)$

DEtoRE(DE,F,a):= block([de,terms,rec,RE,aterm,i],
    de: lhs(expand(DE)),
    if(freeof("+",de)) then terms: [de]
    else terms: args(de),
    rec: map(lambda([v],rectermfun(v,F,a)),terms),
    RE: apply("+",rec),
    aterm: sublist(listofvars(RE), lambda([v], not atom(v))),
    aterm: sort(sublist(aterm, lambda([v], is(equal(op(a),op(v)))))),
    if(length(rec)<2) then RE=0
    else (
        for i: 1 thru length(aterm) do RE: map(factor, collectterms(RE,aterm[i])),
        RE=0
    )
)$

/**** CODE TO HAVE THE RE DIRECTLY ****/

kill(f)$
/*** Non linear case ***/
FindQRE(f,z,a):=block([F,DE],
    DE: QDE(f,F(z)),
    if(DE#false) then (
        /*k0: lopow(ratdisrep(taylor(f,z,0,0)),z),
        if(k0<0) then k0: 2*(k0-derivdegree(DE,F(z),z))
        else */
        k0:0,
        UQDEtoRE(DE,F(z),a,k0)
    )
    else false
)$

FPSFindQRE(f,z,a):=block([F,DE],
    DE: QDE(f,F(z)),
    if(DE#false) then QDEtoRE(DE,F(z),a,0)
)$

FindNLRE(f,z,a):=block([F,DE],
    DE: NLDE(f,F(z)),
    if(DE#false) then QDEtoRE(DE,F(z),a,0)
)$

/*** simple case ***/
FindRE(f,z,a,[Hde_step]):= block([de_step,F,HDE], 
    if(emptyp(Hde_step)) then de_step: 1
    else de_step: Hde_step[1],
    HDE: HolonomicDE(f,F(z),de_step),
    if(HDE#false) then DEtoRE(HDE,F(z),a) 
    else false
)$

/************************************************************* Taylor Approximation computations *********************************************/

pp:p,
kill(x,p,HQ)$

Taylor(f,z,z0,N):=catch(block([g,limitz0,RE,d,C,Sn0,n0,T,I,rec,a,j],
    if(z0=inf or z0=-inf) then g: subst(Sign(z0)*1/z,z,f)
    else g: subst(z+z0,z,f),
    assume(z>0),
    errormsg: false,
    limitz0: errcatch(taylor(g,z,0,lopow(f,z))),
    if(length(limitz0)<1) then (
        print("Not analytic at", z0),
        throw(f)
    ),
    errormsg: true,
    RE: FindRE(g,z,a[n]),
    if(RE=false) then throw(false),
    C: REcoeff(RE,a[n]),
    d: length(C)-1,
    if(d>0) then Sn0: map(rhs, solve(first(C)*last(C),n))
    else throw(ratdisrep(taylor(f,z,z0,N))),
    Sn0: sublist(Sn0, integerp),
    n0: lmax(Sn0)+1,
    if(N<=n0+d-1) then throw(subst(0,%e^(-inf),ratdisrep(taylor(f,z,z0,N)))),
    if(z0=inf or z0=-inf) then (
        T: ratdisrep(taylor(f,z,z0,n0+d-1)),
        T: subst(0,%e^(-inf),T),
        I: makelist(a[j]=coeff(T,1/z,j),j,n0,n0+d-1),
        rec: a[n+d]=-sum(C[j]*a[n+j-1],j,1,d)/C[d+1],
        for j:n0 thru N-d do 
            I: endcons(radcan(subst(I,subst(j,n,rec))),I),
        T + sum(rhs(I[j])*(1/z)^(n0+j-1),j,d+1,N+1-n0)
    )
    else(
        T: ratdisrep(taylor(f,z,z0,n0+d-1)),
        if(freeof(log(z),T) and not ratfunp(T,[z])) then T: limit(T,z,z0,plus),
        I: makelist(a[j]=coeff(T,z-z0,j),j,n0,n0+d-1),
        rec: a[n+d]=-sum(C[j]*a[n+j-1],j,1,d)/C[d+1],
        for j:n0 thru N-d do 
            I: endcons(radcan(subst(I,subst(j,n,rec))),I),
        T + sum(rhs(I[j])*(z-z0)^(n0+j-1),j,d+1,N+1-n0)
    )
))$


QTaylor(fun,z,x,p):=catch(block([Rep,T,rec,I,lI,iteration,j,zpow,j0],
    NLDEflag: false,
    if(QTaylorSave[0]=fun and QTaylorSave[4]=x) then (
        I: QTaylorSave[3],
        zpow: QTaylorSave[2],
        lI: length(I)-zpow,
        if(p<lI) then sum(rhs(I[j+1])*(z-x)^(j-zpow),j,0,p+zpow)
        else (
            [T,rec]: QTaylorSave[1],
            iteration: p-lI,
            simpsum:true,
            T: subst(p+zpow,inf,T),
            j0: rhs(linsolve(first(lhs(rec))=lI+zpow,n)[1]),
            for j:j0 thru j0+iteration do
                I: endcons(ratsimp(subst(I,subst(j,n,rec))),I),
            simpsum:false,
            QTaylorSave[3]:I,
            subst(I,T)                    
        )
    )
    else (
        Rep: QNF(fun,z,n,x),
        if(Rep#false and integerp(p)) then (
            if(not listp(Rep)) then (
                print("your input expression is a polynomial"),
                ratdisrep(taylor(fun,z,x,p))
            )
            else (
                [T,rec,I,I]: Rep,
                QTaylorSave[0]:fun,
                QTaylorSave[1]:[T,rec],
                QTaylorSave[4]: x,
                zpow: hipow(T,z),
                zpow: rhs(linsolve(zpow,n)[1]),
                QTaylorSave[2]: zpow,
                lI:length(I)-zpow,
                if(p<=lI) then (
                    QTaylorSave[3]:I,
                    ratdisrep(taylor(fun,z,x,p))
                )
                else(
                    iteration: p-lI,
                    simpsum:true,
                    T: subst(p+zpow,inf,T),
                    for j:0 thru iteration do
                        I: endcons(ratsimp(subst(I,subst(j,n,rec))),I),
                    simpsum:false,
                    QTaylorSave[3]:I,
                    subst(I,T)
                )
            )
        )
    )
))$

/********************************************************************************************************************************************/

/*************** List of polynomials coefficients of an RE *******************************************/

RERE:RE$
kill(RE)$

REcoeff(RE,a):=block([n,recterm,e0,re,o,i],
    n:first(a),
    recterm: sublist(listofvars(RE), lambda([v], not atom(v))),
    recterm: sort(sublist(recterm, lambda([v], is(equal(op(a),op(v)))))),
    e0:rhs(linsolve(first(recterm[1]),n)[1]),
    recterm: subst(n+e0,n,recterm),
    re: lhs(subst(n+e0,n,RE)),
    o: -rhs(linsolve(first(last(recterm)),n)[1]),
    makelist(coeff(re,subst(n+i,n,a)),i,0,o)
)$

/**************** simplification of an RE *********************/

kill(LRE)$

simpRE(LRE,n):=block([lre,numlre,denomlre,comfactnum,comfactden],
    lre: map(factor, LRE),
    numlre: map(num, lre),
    denomlre: map(denom, lre),
    comfactnum: factor(lreduce('gcd,numlre)),
    comfactden: factor(lreduce('lcm,denomlre)),
    map(lambda([v], factor(xthru(v*comfactden/comfactnum))),lre)
)$

/******************** Laurent Polynomial Part **************************/


LPolyPart(f,z):=block([RE,d,N,M],
    RE: FindRE(f,z,a[n]),
    if(RE#false) then(
        RE: REcoeff(RE,a[n]),
        d: length(RE)-1,
        M: map(rhs, solve(subst(n-d,n,last(RE)),n)),
        M: lmin(sublist(M, integerp)),
        N: sublist(map(rhs, solve(first(RE),n)),integerp),
        if(length(N)<1) then [0, M]
        else (
            N: lmax(N),
            [ratdisrep(taylor(f,z,0,N)), N+1]
        )
    )
)$

/*********************************************************** Petkovsek's original algorithm ******************************************************/

PolyPetkov(RE,a):=block([L],
  L: REcoeff(RE,a),
  Poly(L,first(a))
)$

Poly(L,n):= block([d,Li,m,lm,C,s,b,j,lb,bs,DN,D,N,S,Rec,CoefRec,Sol],
    %rnum_list:[],
    d:length(L),
    Li:expand(L),
    m:lmax(map(lambda([v], hipow(v,n)),Li)),
    lm:max(d-1-m,0),
    C:map(lambda([v], allcoeffsBound(v,n,m,lm)),Li),
    s:0,
    b:ratsimp(sum(C[i][1],i,1,d)),
    j:1,
    while b=0 do(
        s:s+1,
        b: ratsimp(sum(C[i][s+1],i,1,d)),
        j:1,
        while b=0 and j<=s do(
            b: ratsimp(sum((i-1)^j*C[i][s-j+1],i,1,d)),
            j:j+1
        )
    ),
    lb:[b],
    j0:j,
    if(j<=s) then
        while j<=s do(
            lb:endcons(sum((i-1)^j*C[i][s-j+1],i,1,d),lb),
            j:j+1
        ),
    DN: sum(binomial(N,i)*lb[i-j0+2],i,j0-1,s),
    D: map(rhs, solve(DN,N)),
    N: lmax(sublist(D,integerp)),
    if(N>=0) then (
        S: sum(concat(c,i)*n^i,i,0,N),
        Rec: expand(sum(subst(n+i-1,n,S)*Li[i],i,1,d)),
        CoefRec: allcoeffsBound(Rec,n,hipow(Rec,n),0),
        linsolvewarn: false,
        Sol: linsolve(CoefRec,makelist(concat(c,i),i,0,N)),
        linsolvewarn: true,
        S: expand(subst(Sol,S)),
        S: makelist(num(factor(coeff(S,%rnum_list[j]))),j,1,length(%rnum_list)),
        sum(S[j]*%rnum_list[j],j,1,length(%rnum_list))
    )
    else false
)$

kill(e)$


filter(e,F,n):=block([flag,j],
    flag:true,
    j:1,
    while flag and j<=length(F) do (
        flag: is(0#resultant(F[j],e,n)),
        j:j+1
    ),
    flag
)$

filtersetprod(S,n):=catch(block([sp,F],
    sp:1,
    F:[],
    for e in S do 
        if(filter(e,F,n)) then (
            sp: sp*e,
            F:endcons(e,F)
        )
        else throw(1),
    sp
))$

colTerm(func,law):=block([L,T],
    if(atom(func)) then [func]
    else (
        L:args(func),
        T:apply(law,L),
        if(T=func) then L
        else [func]
    )
)$

PP:P$
kill(P)$

Cmonicfac(P,n):=block([numfacP,l,ss,L,powL,p2,p],
    numfacP:num(factor(P)),
    if(atom(numfacP)) then l: [numfacP]
    elseif(op(numfacP)="*") then l:colTerm(numfacP,"*")
    else l: colTerm(-numfacP,"*"),
    L:{},
    for p in l do(
        ss: map(rhs,solve(p,n)),
        for i:1 thru length(ss) do (
            if(constantp(ss[i])) then L:union(L,setify(makelist((n-ss[i])^j,j,1,multiplicities[i])))
            else (
                p2: expand(ss[i]/coeff(ss[i],n,hipow(ss[i],n))),
                L: union(L,setify(makelist(p2^j,j,1,hipow(p,ss[i]))))
            )
        )
    ),
    powL:setdifference(powerset(L),{{}}),
    union({1},map(lambda([v],filtersetprod(v,n)),powL))
)$

Qirfactor(expr,n):= catch(block([ir,logform,mlog],
    if(constantp(expr)) then throw([1,1]),
    logexpand: true,
    logform: log(expr),
    logexpand: false,
    mlog: args(logform),
    if(length(mlog)=2) then (
        ir: expand(exp(mlog[2])),
        [mlog[1],expand(ir/coeff(ir,n,hipow(ir,n)))]   
    )
    else [1,expand(expr/coeff(expand(expr),n,hipow(expand(expr),n)))]
))$

Qmonicfac(P,n):=block([numfacP,l,j,L,powL,pp,e,p],
    numfacP:num(factor(P)),
    if(atom(numfacP)) then l: [numfacP]
    elseif(op(numfacP)="*") then l:colTerm(numfacP,"*")
    else l: colTerm(-numfacP,"*"),
    L:{},
    for p in l do(
        [e,pp]: Qirfactor(factor(p),n),
        L: union(L,setify(makelist(pp^j,j,1,e)))
    ),
    powL:setdifference(powerset(L),{{}}),
    union({1},map(lambda([v],filtersetprod(v,n)),powL))
)$

HyperPetkov(RE,a,[F]):=catch(block([K,L,n,Hyp,d,P0,Pd,mfacP0,mfacPd,A,B,dAB,DAB:{},LP,m,Alphacoef,Zsol,zsol,Pol,nsol],
    domain:real,
    %rnum_list:[],
    if(emptyp(F)) then K: numberp
    elseif F[1]=C then K: constantp
    elseif F[1]=Q then K: numberp
    else (
        print(F[1], " is unknown. Please use Q or C"),
        throw(false)
    ),
    nsol:0,
    L: REcoeff(RE,a),
    n: first(a),
    Hyp:{},
    d:length(L),
    P0:factor(subst(n-1,n,first(L))),
    Pd:factor(subst(n-d+1,n,last(L))),
    if(K(sqrt(2))) then (
        mfacP0: Cmonicfac(P0,n),
        mfacPd: Cmonicfac(Pd,n)
    )
    else (
        mfacP0: Qmonicfac(P0,n),
        mfacPd: Qmonicfac(Pd,n)
    ),
    for A in mfacP0 do
        for B in mfacPd do (
            dAB: hipow(expand(A),n)-hipow(expand(B),n),
            if(not member(dAB,DAB)) then (
                LP:[],
                for j:1 thru d do 
                    LP: endcons(expand(L[j]*prod(subst(n+l,n,A),l,1,j-1)*prod(subst(n+k,n,B),k,j,d-1)),LP),
                m:lmax(map(lambda([v], hipow(v,n)),LP)),
                Alphacoef: map(lambda([v],coeff(v,n,m)),LP),
                Zsol:map(rhs,solve(sum(Alphacoef[i]*Z^(i-1),i,1,d),Z)),
                Zsol:sublist(Zsol, lambda([v], v#0 and K(v))),
                if(length(Zsol)=0) then DAB: adjoin(dAB,DAB),
                for zsol in Zsol do (
                    Pol: Poly(makelist(zsol^(i-1)*LP[i],i,1,d),n),
                    if(Pol#false and Pol#0) then (
                        Pol: setify(create_list(coeff(Pol,rnumi),rnumi,%rnum_list)),
                        %rnum_list:[],
                        Pol: map(lambda([v],factor(zsol*(subst(n+1,n,A)/subst(n+1,n,B))*(subst(n+1,n,v)/v))),Pol),
                        Hyp: union(Hyp,Pol),
                        nsol: cardinality(Hyp),
/*                         Hyp: adjoin(factor(zsol*(subst(n+1,n,A)/subst(n+1,n,B))*(subst(n+1,n,Pol)/Pol)), Hyp), */
                        if(nsol=d-1) then throw(Hyp)
                    )
                )
            )
        ),
    Hyp
))$

kill(nulist,leadcoeffs,ijcouple)$
/*********************************************************** complex van Hoeij *************************************************/
ComplexfindC(nulist,leadcoeffs, ijcouple):=block([LC,pos,cnulist,already,nu,samenu,ucouple,eqC,i,x,Csol,C],
    LC: [],
    cnulist: copylist(nulist),
    pos: 1,
    already: [],
    while cnulist # [] do (
        nu: pop(cnulist),
        if(integerp(nu) and not member(pos,already)) then (
            samenu: sublist_indices(nulist, lambda([v],v=nu)),
            samenu: sublist(samenu, lambda([v], not disjointp(ijcouple[v],ijcouple[pos]))),
            ucouple: {},
            for k in samenu do ucouple: union(ucouple,ijcouple[k]),
            eqC:0,
            for i in ucouple do eqC: eqC + leadcoeffs[i]*x^(i-1),
            if(eqC#0) then (
                Csol: map(rhs, solve(eqC,x)),
                Csol: sublist(Csol, lambda([v],constantp(v) and v#0 and bigexprtest(v)<6)),
                for C in Csol do LC: endcons([nu,C],LC)
            ),
            already: append(already,samenu)
        ),
        pos: pos+1
    ),
    ratsimp(LC)
)$


kill(c)$
onesideComplexfloor(c):=block([r],
    r: realpart(c),
    if(integerp(floor(r))) then (
        r: r-floor(r)-1,
        r+%i*imagpart(c)
    )
    else constantpart(c)
)$

constantpart(c):=block([listc,v],
    if(atom(c)) then c
    else (
        if(op(c)="+") then (
            listc: args(c),
            listc: sublist(listc,lambda([v], not integerp(v))),
            lsum(v,v,listc)
        )
        else c
    )

)$

Complexlocaltype(L,n):=block([d,ijcouple,i,nulist,leadcoeffs,nuc,LC,lc,vlc,kc,bpoleq,t,eq,b,soleq],
    d: length(L),
    ijcouple: listify(powerset(setify(makelist(i,i,1,d)),2)),
    nulist: map(lambda([v],(hipow(L[first(v)],n)-hipow(L[last(v)],n))/(last(v)-first(v))),ijcouple),
    leadcoeffs: map(lambda([v],coeff(v,n,hipow(v,n))),L),
    nuc:ComplexfindC(nulist,leadcoeffs,ijcouple),
    LC:[],
    for lc in nuc do(
        vlc: lc[2]*n^(lc[1])*(1+b/n),
        bpoleq: sum(L[kc+1]*product(subst(n+i,n,vlc),i,0,kc-1),kc,0,d-1),
        t:1,
        eq:0,
        while(eq=0) do (
            eq: first(taylor(bpoleq,n,inf,t)),
            t: t+1
        ),
        soleq: map(rhs, solve(eq,b)),
        if(length(soleq)>0) then (
            soleq: map(lambda([v], onesideComplexfloor(v)),soleq),
            for i:1 thru length(soleq) do LC: endcons(endcons(soleq[i],lc),LC)
        )
        
    ),
    ratsimp(LC)
)$
kill(roots,mult)$
ComplexmodZ(roots,mult):=block([S,pos,already,modroots,cmodroots,mroot,sameroot,pow,pr,lpow],
    S: {},
    already: [],
    pos: 1,
    modroots: map(lambda([v], onesideComplexfloor(v)),roots),
    cmodroots: copylist(modroots),
    while cmodroots#[] do (
        mroot: pop(cmodroots),
        if(not member(pos,already)) then (
            sameroot: sublist_indices(modroots, lambda([v],v=mroot)),
            lpow: create_list(mult[k],k,sameroot),
            pow: [lmin(lpow),lsum(pr,pr,lpow)],
            S: adjoin([mroot,pow],S),
            already: append(already,sameroot)
        ),
        pos: pos+1
    ),
    S
)$
bigexprtest(expr):=block([b,A],
    b:0,
    if(atom(expr)) then b
    else(
        A:args(expr),
        while(length(A)>0 and b<10) do (
            b: b+1,
            A: sublist(A,lambda([v],not atom(v))),
            if(length(A)>0) then A: lreduce(append,map(args, A))
        )
    ),
    b
)$
ComplexvanHoeijmonicfac(P,n):=catch(block([roots,indratroot,mult,modZroots,L1,L2,E,bigr],
    roots: map(rhs, solve(P,n)),
    bigr: lmax(map(bigexprtest, roots)),
    if(bigr>5) then throw({0}),
    indratroot: sublist_indices(roots, constantp),
    roots: map(lambda([v], roots[v]),indratroot),
    mult: map(lambda([v], multiplicities[v]),indratroot),
    modZroots: ComplexmodZ(roots,mult),
    L1: map(lambda([r], adjoin(1,setify(makelist((n-r[1])^j,j,r[2][1],r[2][2])))),modZroots),
    L2:{1},
    for E in L1 do
        L2: map(lambda([l], lprod(l)), cartesian_product(L2,E)),
    L2
))$

Complexcheck_localtype(term,n):=block([Rn,nuRn,tv,tayRn,cRn,bRn],
    Rn: ratsimp(term),
    nuRn: hipow(num(Rn),n) - hipow(denom(Rn),n),
    Rn: ratsimp(subst(1/tv,n,ratsimp(Rn/n^nuRn))),
    tayRn: ratdisrep(taylor(Rn,tv,0,2)),
    cRn: coeff(tayRn,tv,0),
    bRn: coeff(tayRn,tv,1)/cRn,
    [nuRn,cRn,onesideComplexfloor(bRn)]
)$
Complexirfactor(P,n):=block([S,r],
    S: map(rhs,solve(P,n)),
    S: map(lambda([v],n-v),S),
    lprod(S)
)$
kill(A,B,d)$
ComplexUdenom(A,B,d,n):= block([U,V,W,h,D,P],
    U: 1,
    V: Complexirfactor(subst(n-d,n,B),n),
    W: Complexirfactor(A,n),
    D: hvw(V,W,n),
    if(cardinality(D)=0) then U
    else(
        D: sort(listify(D),'ordergreatp),
        for h in D do (
            P: gcd(V,subst(n+h,n,W),n),
            V: V/P,
            W: W/subst(n-h,n,P),
            U: U*product(subst(n-i,n,P),i,0,h)
        ),
        U
    )
)$
ComplexRatsolve(LRE,n,x):= block([d,U,p,tayU,m,lpolre,pol,N,S,Rec,CoefRec,Sol,P],
        d: length(LRE),
        U: ComplexUdenom(first(LRE),last(LRE),d-1,n),
        N: x+hipow(expand(U),n),
        if(N>=0 and N<21) then (
            lpolre: simpRE(makelist(LRE[i+1]/subst(n+i,n,U),i,0,d-1),n),
            if(lsum(pol,pol,lpolre)=0) then {1/U}
            else (
                m: lmax(map(lambda([v], hipow(v,n)),expand(lpolre))),
                S: sum(concat(c,i)*n^i,i,0,N),
                Rec: expand(sum(subst(n+i-1,n,S)*lpolre[i],i,1,d)),
                CoefRec: allcoeffsBound(Rec,n,m*N,0),
                linsolvewarn: false,
                Sol: linsolve(CoefRec,makelist(concat(c,i),i,0,N)),
                linsolvewarn: true,
                P: subst(Sol,S),
                if(P#0) then (
                    P: makelist(coeff(expand(P),v),v,%rnum_list),
                    setify(map(factor, P/U))
                )
                else false
            )
        )
        else false
)$

kill(recoeff)$
ComplexvanHoeij(recoeff,n):= catch(block([Hyp,d,dsol,P0,Pd,inftype,inftypeset,cvalue,c,candidates,bettercandidates,bbettercandidates,Cchltype,chs,term,Lre,sR],
    domain:complex,
    Hyp: {},
    inftype: Complexlocaltype(expand(recoeff),n),
    if(length(inftype)=0) then Hyp 
    else(
        d: length(recoeff),
        dsol: length(inftype),
        inftypeset: setify(inftype),
        P0: subst(n-1,n,first(recoeff)),
        Pd: subst(n-d+1,n,last(recoeff)),
        candidates: cartesian_product(ComplexvanHoeijmonicfac(P0,n),ComplexvanHoeijmonicfac(Pd,n)),
        if(length(candidates)>0 and member(0,first(candidates))) then throw(Hyp),
        candidates: map(lambda([v],factor(v[1]/v[2])),candidates),
        cvalue: map(lambda([v], v[2]), inftypeset),
        bettercandidates:{},
        for c in cvalue do bettercandidates: union(bettercandidates, map(lambda([v], c*v),candidates)),
        bbettercandidates: subset(bettercandidates, lambda([v], member(Complexcheck_localtype(v,n),inftypeset))),
        if(dsol<d) then 
            for term in bbettercandidates do (
                Cchltype: Complexcheck_localtype(term,n),
                if( member(Cchltype,inftype)) then (
                    Lre: makelist(recoeff[i+1]*product(subst(n+j,n,term),j,0,i-1),i,0,d-1),
                    domain:real,
                    chs: check_solution(Lre,n),
                    domain:complex,
                    if(length(chs)>0) then (
                        chs: lmax(chs),
                        sR: ComplexRatsolve(simpRE(Lre,n),n,chs),
                        if(sR#false) then (
                            Hyp: union(Hyp, map(lambda([v], v*pochfactorsimp(term,n)),sR)),
                            delete(Cchltype,inftype,1),
                            if(cardinality(Hyp)=dsol) then throw(Hyp)
                        )
                    )
                )
            )
        else 
            for term in bbettercandidates do (
                    Lre: makelist(recoeff[i+1]*product(subst(n+j,n,term),j,0,i-1),i,0,d-1),
                    chs: check_solution(Lre,n),
                    if(length(chs)>0) then (
                        chs: lmax(chs),
                        sR: ComplexRatsolve(simpRE(Lre,n),n,chs),
                        if(sR#false) then Hyp: union(Hyp, map(lambda([v], v*pochfactorsimp(term,n)),sR))
                    )
            ),
        Hyp
    )
))$


/******************************************************* van Hoeij approach ******************************************************************/


/********************************************* local type of the of the hypergeometric solution ***************************************/

findC(nulist,leadcoeffs, ijcouple):=block([LC,pos,cnulist,already,nu,samenu,ucouple,ki,eqC,i,x,Csol,C],
    LC: [],
    cnulist: copylist(nulist),
    pos: 1,
    already: [],
    while cnulist # [] do (
        nu: pop(cnulist),
        if(integerp(nu) and not member(pos,already)) then (
            samenu: sublist_indices(nulist, lambda([v],v=nu)),
            samenu: sublist(samenu, lambda([v], not disjointp(ijcouple[v],ijcouple[pos]))),
            ucouple: {},
            for ki in samenu do ucouple: union(ucouple,ijcouple[ki]),
            eqC:0,
            for i in ucouple do eqC: eqC + leadcoeffs[i]*x^(i-1),
            if(eqC#0) then (
                Csol: ratsimp(map(rhs, solve(eqC,x))),
                Csol: sublist(Csol, lambda([v],numberp(v) and v#0)),
                for C in Csol do LC: endcons([nu,C],LC)
            ),
            already: append(already,samenu)
        ),
        pos: pos+1
    ),
    LC
)$

localtype(L,n):=block([d,ijcouple,i,nulist,leadcoeffs,nuc,LC,lc,vlc,kj,bpoleq,t,eqargs,eq,b,soleq],
    d: length(L),
    ijcouple: listify(powerset(setify(makelist(i,i,1,d)),2)),
    nulist: map(lambda([v],(hipow(L[first(v)],n)-hipow(L[last(v)],n))/(last(v)-first(v))),ijcouple),
    leadcoeffs: map(lambda([v],coeff(v,n,hipow(v,n))),L),
    nuc:findC(nulist,leadcoeffs,ijcouple),
    LC:[],
    for lc in nuc do(
        vlc: lc[2]*n^(lc[1])*(1+b/n),
        bpoleq: sum(L[kj+1]*product(subst(n+i,n,vlc),i,0,kj-1),kj,0,d-1),
        t:1,
        eq:0,
        while(eq=0) do (
            eq: first(taylor(bpoleq,n,inf,t)),
            t: t+1
        ),
        soleq: map(rhs, solve(eq,b)),
        if(length(soleq)>0) then (
            soleq: map(lambda([v], v-floor(v)-1),soleq),
            for i:1 thru length(soleq) do LC: endcons(endcons(soleq[i],lc),LC)
        )
        
    ),
    ratsimp(LC)
)$

/******************************************** collecting monic factors (trailing and leading) ****************************************/


modZ(roots,mult):=block([S,pos,already,modroots,cmodroots,mroot,sameroot,lpow,pow],
    S: {},
    already: [],
    pos: 1,
    modroots: map(lambda([v], v-floor(v)-1),roots),
    cmodroots: copylist(modroots),
    while cmodroots#[] do (
        mroot: pop(cmodroots),
        if(not member(pos,already)) then (
            sameroot: sublist_indices(modroots, lambda([v],v=mroot)),
            lpow: create_list(mult[kj],kj,sameroot),
            pow: [lmin(lpow), lsum(pr,pr,lpow)],
            S: adjoin([mroot,pow],S),
            already: append(already,sameroot)
        ),
        pos: pos+1
    ),
    S
)$

lprod(L):= block([j],
    product(L[j],j,1,length(L))
)$

vanHoeijmonicfac(P,n):=block([roots,indratroot,mult,modZroots,L1,L2,E],
    roots: map(rhs, solve(P,n)),
    indratroot: sublist_indices(roots, ratnump),
    roots: map(lambda([v], roots[v]),indratroot),
    mult: map(lambda([v], multiplicities[v]),indratroot),
    modZroots: modZ(roots,mult),
    L1: map(lambda([r], adjoin(1,setify(makelist((n-r[1])^j,j,r[2][1],r[2][2])))),modZroots),
    L2:{1},
    for E in L1 do
        L2: map(lambda([l], lprod(l)), cartesian_product(L2,E)),
    L2
)$


/******************************************* checking for infinite type *************************************************/

check_localtype(term,n):=block([Rn,nuRn,tv,tayRn,cRn,bRn],
    Rn: ratsimp(term),
    nuRn: hipow(num(Rn),n) - hipow(denom(Rn),n),
    Rn: ratsimp(subst(1/tv,n,ratsimp(Rn/n^nuRn))),
    tayRn: ratdisrep(taylor(Rn,tv,0,2)),
    cRn: coeff(tayRn,tv,0),
    bRn: coeff(tayRn,tv,1)/cRn,
    [nuRn,bRn-floor(bRn)-1]
)$

remove_localtype(term,n):=block([Rn,nuRn,tv,tayRn,cRn,bRn],
    Rn: ratsimp(term),
    nuRn: hipow(num(Rn),n) - hipow(denom(Rn),n),
    Rn: ratsimp(subst(1/tv,n,ratsimp(Rn/n^nuRn))),
    tayRn: ratdisrep(taylor(Rn,tv,0,2)),
    cRn: coeff(tayRn,tv,0),
    bRn: coeff(tayRn,tv,1)/cRn,
    [nuRn,cRn,bRn-floor(bRn)-1]
)$


/************************************ Rational solutions of Holonomic RE *************************************/
kill(m,lm)$
allcoeffsBound(P,x,m,lm):= block([l,i],
     l: [], 
     for i:-lm thru m do (l : cons(coeff(P,x,i),l)), 
     l
)$
/*********************************** Universal denominator **********************************************/

irfactor(expr,n):=block([ir,logform,mlog],
    logexpand: true,
    logform: log(expr),
    logexpand: false,
    mlog: args(logform),
    if(length(mlog)=2) then (
        ir: expand(exp(mlog[2])),
        expand(ir/coeff(ir,n,hipow(ir,n)))   
    )
    else expand(expr/coeff(expand(expr),n,hipow(expand(expr),n)))
)$


colTerm2(func,law):=block([f1,L,T],
    f1: func,
    if(atom(f1)) then [f1]
    else (
        if(op(f1)="-") then f1:(-1)*f1,
        if(atom(f1)) then [f1]
        else(
            L:args(f1),
            T:apply(law,L),
            if(xthru(T/f1)=1) then L
            else [f1]
        )
    )
)$

kill(V,W)$
hvw(V,W,n):= block([irv,irw,H,hip,an1,bn1,h],
    irv: sublist(colTerm2(V,"*"),lambda([v], not(freeof(n,v)))),
    irw: sublist(colTerm2(W,"*"),lambda([v], not(freeof(n,v)))),
    irv: map(lambda([v],irfactor(v,n)),irv),
    irw: map(lambda([v],irfactor(v,n)),irw),
    H:{},
    for w in irw do
         for v in irv do(
            hip: hipow(w,n),
            if(hip=hipow(v,n) and coeff(w,n,hip)=coeff(v,n,hip)) then (
                an1: coeff(w,n,hip-1),
                bn1: coeff(v,n,hip-1),
                h: (bn1-an1)/hip,
                if(integerp(h) and h>=0) then 
                    if(hip=1 or (hip>1 and expand(subst(n+h,n,w))=v)) then (
                        H: adjoin(h,H)
                    )
            )
        ),
      H
)$

Udenom(A,B,d,n):= block([U,V,W,h,D,P],
    U: 1,
    V: subst(n-d,n,B),
    W: A,
    D: hvw(V,W,n),
    if(cardinality(D)=0) then U
    else(
        D: sort(listify(D),'ordergreatp),
        for h in D do (
            P: gcd(V,subst(n+h,n,W),n),
            V: V/P,
            W: W/subst(n-h,n,P),
            U: U*product(subst(n-i,n,P),i,0,h)
        ),
        U
    )
)$


Ratsolve(LRE,n,x):= block([d,U,p,m,lpolre,pol,N,S,Rec,CoefRec,Sol,P],
        d: length(LRE),
        U: Udenom(first(LRE),last(LRE),d-1,n),
        N: x+hipow(expand(U),n),
        if(N>=0) then (
            lpolre: simpRE(makelist(LRE[i+1]/subst(n+i,n,U),i,0,d-1),n),
            if(lsum(pol,pol,lpolre)=0) then {1/U}
            else (
                m: lmax(map(lambda([v], hipow(v,n)),expand(lpolre))),
                S: sum(concat(c,i)*n^i,i,0,N),
                Rec: expand(sum(subst(n+i-1,n,S)*lpolre[i],i,1,d)),
                CoefRec: allcoeffsBound(Rec,n,m*N,0),
                linsolvewarn: false,
                Sol: linsolve(CoefRec,makelist(concat(c,i),i,0,N)),
                linsolvewarn: true,
                P: expand(subst(Sol,S)),
                if(P#0) then (
                    P: makelist(coeff(P,v),v,%rnum_list),
                    setify(map(factor, P/U))
                )
                else false
            )
        )
        else false
)$

/*********************************************** checking a solution term ***************************************************************/
kill(Cr)$
check_solution(Cr,n):=block([d,xx,r,t,expr,numexpr,hipn,xeqs],
    d: length(Cr),
    r: 1+xx/n,
    t: 0,
    expr: 0,
    while(expr=0) do (
        expr: ratsimp(taylor(sum(Cr[i+1]*product(subst(n+j,n,r),j,0,i-1),i,0,d-1),n,inf,t)),
        t: t+1
    ),
    numexpr: expand(num(expr)),
    hipn: hipow(numexpr,n),
    xeqs: coeff(numexpr,n,hipn),
    xeqs: ratsimp(map(rhs,solve(xeqs,xx))),
    sublist(xeqs,integerp)
)$
 

/*********************************************** Pochhammer computations for gamma term *************************************************/

factosimp(expr):=catch(block([nexpr,dexpr,nexprsimp,dexprsimp,exprsimp,Anexpr,Adexpr,term],
    if(freeof("!",expr)) then throw(expr)
    else(
        nexpr: num(expr),
        dexpr: denom(expr),
        if(atom(nexpr) or atom(dexpr)) then throw(expr),
        if(op(num(expr))="!" or op(denom(expr))="!") then (
            dexprsimp:1,
            nexprsimp:1,
            if(op(dexpr)="!") then (
                dexprsimp: factor(args(dexpr)[1]),
                dexpr: factor(factorial(expand(dexprsimp-1)))
            ),
            if(op(nexpr)="!") then (
                nexprsimp: factor(args(nexpr)[1]),
                nexpr: factor(factorial(expand(nexprsimp-1)))
            ),
            exprsimp: xthru(nexprsimp*nexpr/(dexprsimp*dexpr)),
            if(num(exprsimp)/nexpr/nexprsimp=1 or denom(exprsimp)/dexpr/dexprsimp=1) then expr
            else exprsimp
        )
        else throw(expr)
    )
))$

pochhammersimp(alpha,n):= block([q,u,t],
    if(not (constantp(alpha) and atom(n) and not(constantp(n)))) then false,
    if(not ratnump(alpha)) then pochhammer(alpha,n)
    elseif(alpha>0) then (
        if(integerp(alpha)) then (alpha+n-1)!/(\alpha-1)!
        else (
            q: denom(alpha),
            if(q#2) then pochhammer(alpha,n)
            else(                                             
                t: floor(alpha),
                minfactorial(makefact((2*(t+n))!/((2*t)!*binomial(t+n,n)*n!*4^n)))
            ) 
        )
    )
    else(  
           u: ceiling(abs(alpha)),
           pochhammersimp(alpha+u,n)*pochhammer(alpha,u)/pochhammer(alpha+n,u)
    )
)$

/* function used to simplify a single pochhammer symbol if possible*/
kill(r)$
transfone(r,k):= block([q,cr,t],
    if(r=0) then (k-1)!
    elseif(ratnump(r)=false) then pochhammer(r,k)
    elseif(integerp(r)=true) then (r+k-1)!/(r-1)!
    elseif(r>0) then (
        q: denom(r),
        if(q#2) then pochhammer(r,k)
        else(                                                                   /*special case when the denominator is 2*/
            t: floor(r),
            minfactorial(makefact((2*(t+k))!/((2*t)!*binomial(t+k,k)*k!*4^k)))
        ) 
     )
      else(  
           cr: ceiling(abs(r)),
           transfone(r+cr,k)*pochhammer(r,cr)/pochhammer(r+k,cr)
      )
)$
kill(R)$
pochfactorsimp(R,k):= block([p, q, teken, Zeros, Poles,zeros, poles, lpol, cpoles, intt, z_0, nfac,pochpol,pochpolnbr,nmpol,dnpol],
    assume(k>0),
    /* quotient of leading coefficient of the expression */
    p: expand(num(R)),
    q: expand(denom(R)),
    teken: coeff(p,k,hipow(p,k))/coeff(q,k,hipow(q,k)),

    /* zeros, poles and their multiplicities */
    zeros: map(rhs, solve(p,k)),
    mzeros: multiplicities,
    poles: map(rhs, solve(q,k)),
    mpoles: multiplicities,

    /* collections of poles and roots where each element occur its multiplicity times */
    Zeros: [],
    Poles: [],
    for i:1 thru length(zeros) do  for j:1 thru mzeros[i] do Zeros: endcons((-1)*zeros[i], Zeros),
    for i:1 thru length(poles) do  for j:1 thru mpoles[i] do Poles: endcons((-1)*poles[i], Poles), 

    /* simplification pochhammer-gamma-factorial  */ 
    nfac: teken^k,
    while Zeros # [] and Poles # [] do (
        z_0: pop(Zeros),
        lpol: length(Poles),
        cpoles: [],
        intt: z_0 - Poles[1],
        while integerp(intt)=false and length(cpoles)<lpol do (
            intt: z_0-Poles[1],
            cpoles: endcons(pop(Poles), cpoles)   
        ),
        if(length(cpoles)<lpol) then (
            if(z_0=0 or Poles[1]=0) then nfac: nfac*transfone(z_0,k)/transfone(Poles[1],k)
            else nfac: factor(nfac*minfactorial(makefact(makegamma(pochhammer(z_0,k)/pochhammer(Poles[1],k))))),
            pop(Poles),
            Poles: append(cpoles,Poles)
        )
        else(
            nfac: nfac*transfone(z_0,k),
            Poles: cpoles
        )        
    ),
    if(Zeros=[] and Poles=[]) then factosimp(nfac)
    elseif(Zeros = []) then factosimp(factor(minfactorial(nfac/apply("*", map(lambda([v], transfone(v,k)),Poles)))))
    else factosimp(factor(minfactorial(nfac * apply("*", map(lambda([v], transfone(v,k)), Zeros)))))
   
)$

/*********************************************** van Hoeij algorithm (approach)  *********************************************************/

vanHoeij(recoeff,n):= catch(block([Hyp,inftype,d,dsol,P0,Pd,cvalue,inftypeset,inftypenub,c,candidates,ccandidates,bettercandidates,chs,term,Lre,sR],
    domain:real,
    Hyp: {},
    inftype: localtype(expand(recoeff),n),
    if(length(inftype)=0) then Hyp 
    else(
        d: length(recoeff),
        dsol: length(inftype),
        inftypeset: setify(inftype),
        P0: subst(n-1,n,first(recoeff)),
        Pd: subst(n-d+1,n,last(recoeff)),
        candidates: map(lambda([v],v[1]/v[2]),cartesian_product(vanHoeijmonicfac(P0,n),vanHoeijmonicfac(Pd,n))),
        cvalue: map(lambda([v], v[2]), inftypeset),
        inftypenub: map(lambda([v],  [v[1],v[3]]),inftypeset),
        ccandidates: subset(candidates, lambda([v], member(check_localtype(v,n),inftypenub))),
        bettercandidates:{},
        for c in cvalue do bettercandidates: union(bettercandidates, map(lambda([v], c*v),ccandidates)),
        if(dsol<d) then (
            for term in bettercandidates do (
                if( member(remove_localtype(term,n),inftype)) then (
                    Lre: makelist(recoeff[i+1]*product(subst(n+j,n,term),j,0,i-1),i,0,d-1),
                    chs: check_solution(Lre,n),
                    if(length(chs)>0) then (
                        chs: lmax(chs),
                        sR: Ratsolve(simpRE(Lre,n),n,chs),
                        if(sR#false) then (
                            Hyp: union(Hyp, map(lambda([v], v*pochfactorsimp(term,n)),sR)),
                            delete(remove_localtype(term,n),inftype,1),
                            if(cardinality(Hyp)=dsol) then throw(Hyp)
                        )
                    )
                )
            ),
            Hyp
        )
        else (
            for term in bettercandidates do (
                Lre: makelist(recoeff[i+1]*product(subst(n+j,n,term),j,0,i-1),i,0,d-1),
                chs: check_solution(Lre,n),
                if(length(chs)>0) then (
                    chs: lmax(chs),
                    sR: Ratsolve(simpRE(Lre,n),n,chs),
                    if(sR#false) then Hyp: union(Hyp, map(lambda([v], v*pochfactorsimp(term,n)),sR))
                )
            ),
            Hyp
        )
    )
))$

HypervanHoeij(RE,a,[F]):= block([],
    if(emptyp(F)) then vanHoeij(REcoeff(RE,a),first(a))
    elseif(F[1]=C) then ComplexvanHoeij(REcoeff(RE,a),first(a))
    elseif(F[1]=Q) then vanHoeij(REcoeff(RE,a),first(a))
    else (
        print(F[1], " is unknown. Please use Q or C"),
        false
    )
)$

/**** Intersection of m-hypergeometric type solutions *******/


ratio(term,n):=block([r],
r: factor(subst(n+1,n,term)/term),
factor(ratsimp(minfactorial(makefact(makegamma(r)))))
)$

sum2hyperRE(term1,term2,a):=block([n,r1,r2,r11,r21,aterm,R,RE],
    n: first(a),
    r1: ratio(term1,n),
    r2: ratio(term2,n),
    r11: subst(n+1,n,r1),
    r21: subst(n+1,n,r2),
    R: [factor((r21*r2-r11*r1)/(r1*r2*(r11-r21))), factor((r1-r2)/(r1*r2*(r11-r21)))],
    aterm: [a,subst(n+1,n,a),subst(n+2,n,a)],
    RE: num(factor(R[2]*aterm[3]+R[1]*aterm[2]+aterm[1])),
    for i: 1 thru 3 do RE: map(factor, collectterms(RE,aterm[i])),
    RE=0
)$

sumhyperRE(H,a):=catch(block([n,term,R,d,k,i,j,M,b,Vcomp,V,aterm,RE],
    if( (not listp(H)) or atom(a)) then (
        print("wrong input(s)"),
        throw(false)
    ),
    n: first(a),
    R: map(lambda([term], ratio(term,n)),H),
    d: length(H),
    R: sublist(R, lambda([term], ratfunp(term,[n]))),
    if(length(R)<d) then (
        print("There are some non hypergeometric terms in Q"),
        throw(false)    
    ),
    M: apply('matrix, makelist(makelist(prod(subst(n+k,n,R[i]),k,1,j-1),j,1,d),i,1,d)),
    b: apply('matrix, makelist([-1/R[i]],i,1,d)),
    Vcomp: makelist(concat('%v,i),i,1,d),
    V: transpose(matrix(Vcomp)),
    linsolvewarn:false,
    V: factor(linsolve(xreduce('append,args(M.V-b)),Vcomp)),
    linsolvewarn:true,
    if(length(%rnum_list)>0) then V:subst(map(lambda([v],v=0),%rnum_list),V),
    V: map(rhs, V),
    aterm: makelist(subst(n+i,n,a),i,0,d),
    RE: num(factor(aterm[1] + sum(V[i]*aterm[i+1],i,1,d))),
    for i: 1 thru d+1 do RE: map(factor, collectterms(RE, aterm[i])),
    RE=0
))$

hypintersect(E1,E2):= block([I,H1,H2,h1,j,flag,h2,r],
    I: {},
    if(cardinality(E1)>cardinality(E2)) then (
        H1: E2,
        H2: listify(H1)
    )
    else (
        H1: E1,
        H2: listify(E2)
    ),
    l2: length(H2),
    for h1 in H1 do (
        j:1,
        flag: false,
        while(not(flag) and j<=l2) do (
            h2: H2[j],
            r: factor(minfactorial(h1/h2)),
            flag: constantp(r),
            j: j+1
        ),
        if(flag) then (
             I: adjoin(h1,I),
             H2: delete(h2,H2),
             l2: l2-1
        )
    ),
    I
)$

hypintersect2(E1,E2,n):= block([I,H1,H2,h1,j,r,h2,Lh,lh,V,r1,S],
    I: {},
    if(cardinality(E1)>cardinality(E2)) then (
        H1: E2,
        H2: listify(H1)
    )
    else (
        H1: E1,
        H2: listify(E2)
    ),
    l2: length(H2),
    for h1 in H1 do (
        if(l2>1) then (
            Lh: [],
            for j:1 thru l2 do (
                h2: H2[j],
                r: factor(minfactorial(h1/h2)),
                if(ratfunp(r,[n])) then Lh: endcons(h2,Lh)
            ),
            if(length(Lh)>1) then (
                lh: length(Lh),
                V: makelist(concat(ic,j),j,1,lh),
                r1: ratio(ratsimp(sum(V[j]*Lh[j],j,1,lh)),n),
                r: subst(n+k,n,ratio(h1,n)),
                S: expand(num(r)*denom(r1)-denom(r)*num(r1)),
                S: allcoeffsBound(S,n,lopow(S,n)+lh-1,-lopow(S,n)),
                linsolvewarn:false,
                S1: linsolve(rest(S,-1),rest(V,-1)),
                S2: map(rhs,solve(subst(S1,S[lh]),k)),
                S2: sublist(S2,integerp),
                linsolvewarn:true,
                if(length(S2)>0) then (
                    I: adjoin(h1,I),
                    H2: sublist(H2, lambda([v], not member(v,Lh))),
                    l2: l2-lh
                )
            )
        )
        
    ),
    I
)$


/****************************************** Hypergeometric type solutions of a given RE *************************************/
kill(vm)$
HyperType(RE, a,[vm]):= block([n,re,d,m,PetvanHoeij,hyp,Hyp,re_m,j,i,b,Nosol,subsol,emptysol],  
    n: first(a),
    re: simpRE(REcoeff(RE, a),n),
    d: length(re),
    if(length(vm)<=1) then (
        if(emptyp(vm)) then PetvanHoeij: vanHoeij
        else PetvanHoeij: vm[1],
        m: 1,
        hyp: PetvanHoeij(re,n),
        Hyp: [],
        if(cardinality(hyp)>0) then Hyp: endcons([1,hyp],Hyp),
        while(m<d-1) do (
            m: m+1,
            re_m: map(lambda([v], [v]),rest(re, -(d-m))),
            j: m+1,
            while(j<=d) do (
                i: mod(j,m),
                if(i=0) then i: m,
                re_m[i]: endcons(re[j],re_m[i]),
                j: j+1
            ),
            Nosol: map(lambda([v], sublist(v,lambda([v],v#0))),re_m),
            Nosol: sublist(Nosol, lambda([v], length(v)=1)),
            if(length(Nosol)=0) then (
                for i:1 thru m do re_m[i]: subst(n-(i-1),n,re_m[i]),
                re_m: subst(m*n,n,re_m),
                re_m: map(lambda([v], sum(v[j+1]*b[n+j],j,0,length(v)-1)),re_m),
                re_m: sublist(re_m,lambda([v],v#0)),
                subsol: map(lambda([v], PetvanHoeij(REcoeff(v,b[n]),n)),re_m),
                emptysol: sublist(subsol, emptyp),
                if(length(emptysol)=0) then (
                    hyp: lreduce(hypintersect, subsol),
                    if(length(hyp)=0) then hyp: lreduce(lambda([E1,E2], hypintersect2(E1,E2,n)), subsol),
                    if(cardinality(hyp)>0) then Hyp: endcons([m,hyp],Hyp)
                )
            )
        ),
        Hyp
    )
    else (
        hyp:{},
        m: vm[1],
        modm: vm[2],
        if(length(vm)<3) then PetvanHoeij: vanHoeij
        else PetvanHoeij: vm[3],
        re_m: map(lambda([v], [v]),rest(re, -(d-m))),
        j: m+1,
        while(j<=d) do (
            i: mod(j,m),
            if(i=0) then i: m,
            re_m[i]: endcons(re[j],re_m[i]),
            j: j+1
        ),
        Nosol: map(lambda([v], sublist(v,lambda([v],v#0))),re_m),
        Nosol: sublist(Nosol, lambda([v], length(v)=1)),
        if(length(Nosol)=0) then (
            for i:1 thru m do re_m[i]: subst(n-(i-1),n,re_m[i]),
            re_m: subst(m*n+modm,n,re_m),
            re_m: map(lambda([v], sum(v[j+1]*b[n+j],j,0,length(v)-1)),re_m),
            re_m: sublist(re_m,lambda([v],v#0)),
            subsol: map(lambda([v], PetvanHoeij(REcoeff(v,b[n]),n)),re_m),
            emptysol: sublist(subsol, emptyp),
            if(length(emptysol)=0) then hyp: lreduce(hypintersect, subsol),
            if(length(hyp)=0) then hyp: lreduce(lambda([E1,E2], hypintersect2(E1,E2,n)), subsol)
        ),
        hyp
    )

)$

mfoldHyper(RE,a,[vm]):=catch(block([n,opa,re],
    if(atom(a)) then (
        print("Wrong input(s)"),
        throw(false)
    )
    else(
        n:args(a),
        opa: op(a),
        if(not (length(n)=1 and atom(n[1]) and atom(opa)) or freeof(n[1],RE) or freeof(opa,RE) or freeof("=",RE)) then (
            print("Wrong input(s)"),
            throw(false)
        )
    ),
    if(length(vm)<=1) then (
        if(emptyp(vm)) then throw(HyperType(RE,a)),
        if(vm[1]=Q) then throw(HyperType(RE,a)),
        if(vm[1]=C) then throw(HyperType(RE,a,ComplexvanHoeij)),
        if(vm[1]#Q and vm[1]#C) then (
            print(vm[1], " is unknown. Please use Q or C"),
            throw(false)
        )
    )
    elseif(length(vm)=2) then (
        re: REcoeff(RE,a),
        if(integerp(vm[1]) and integerp(vm[2])) then (
            if(vm[1]>-1 and vm[2]>-1 and length(re)>vm[1] and vm[1]>vm[2]) then HyperType(RE,a,vm[1],vm[2])
            else {}
        )
        else (
            print("Wrong input(s)"),
            throw(false)
        )
    )
    elseif(length(vm)=3) then (
        if(vm[1]#Q and vm[1]#C) then (
            print(vm[1], " is unknown. Please use Q or C"),
            throw(false)
        )
        elseif(vm[1]=C) then (
            re: REcoeff(RE,a),
            if(integerp(vm[2]) and integerp(vm[3])) then (
                if(vm[2]>-1 and vm[3]>-1 and length(re)>vm[2] and vm[2]>vm[3]) then HyperType(RE,a,vm[2],vm[3],ComplexvanHoeij)
                else {}
            )
        )
        else(
            if(integerp(vm[2]) and integerp(vm[3])) then (
                if(vm[2]>-1 and vm[3]>-1 and length(re)>vm[2] and vm[2]>vm[3]) then HyperType(RE,a,vm[2],vm[3])
                else {}
            )
        )
    )
))$

/********************************************************** FPS computations ***********************************************************/


RE_PolyPart(RE,f,z,a):=block([re,n,nre,Sp,L,polflag,eq,N,mnz],
    n: first(a),
    re: REcoeff(RE,a),
    nre: length(sublist(re, lambda([v],v#0))),
    L:[],
    polflag: true,
    for i:1 thru length(re) do (
        eq: subst(n-(i-1),n,re[i]),
        if(not freeof(n,eq)) then (
            Sp: map(rhs,solve(eq,n)),
            if(polflag) then polflag: polflag and is(length(Sp)=1) and integerp(Sp[1]) and constantp(diff(eq,n)),
            L: append(L,sublist(Sp,integerp))
        )
    ),
    N:-1,
    Sp: sublist(map(rhs, solve(re[1],n)),integerp),
    if length(Sp)>0 then N: lmax(Sp),
    L: listify(setify(L)),
    polflag: polflag and (is(length(L)=nre) or is(nre=1)),
    mnz: 1+max(0,lmax(L)),
    N: max(-1,N),
    [ratdisrep(taylor(f,z,0,N)),N+1,polflag,mnz]
)$

load(to_poly_solve)$

RE2_PolyPart(RE,f,z,n):=block([S,N,arbN],
    S: map(rhs, solve(first(RE)*last(RE),n)),
    arbN: sublist(S, lambda([v], not complex_number_p(v))),
    S: sublist(S,integerp),
    if(length(arbN)>0) then (
        if(length(S)<1) then [0,lmax(arbN)]
        else (
            N: lmax(S),
            if(ratdisrep(taylor(f,z,0,N))=0) then [0,lmax(arbN)+1]
            else [ratdisrep(taylor(f,z,0,N)),N+1]
        )
    )
    else (
        if(length(S)>0) then N: lmax(S)
        else N:-1,
        [ratdisrep(taylor(f,z,0,N)),N+1]
    )
)$

kill(ht,RE,algo)$
allhypform(ht,z,RE,a,algo):=block([n,m,Mh,j,hypmj],
    n: first(a),
    m: ht[1],
    Mh: [],
    Mh: append(Mh,listify(map(lambda([v], v*z^(m*n)),ht[2]))),
    for j:1 thru m-1 do(
        hypmj: HyperType(RE,a,m,j,algo),
        Mh:append(Mh,listify(map(lambda([v], v*z^(m*n+j)),hypmj)))
    ),
    [m,Mh]
)$

Puiseuxnbrfun(P0,Pd,n):=block([L,k],
    L: append(map(rhs, solve(Pd,n)), map(rhs, solve(P0,n))),
    L: sublist(L, numberp),
    k: 1,
    if(length(L)>0) then k: lreduce(lcm, map(denom,L)),
    k
)$

kill(LT)$
funPuiseux(LT,n):=block([L,p],
    L: append(map(rhs, solve(LT[1],n)), map(rhs, solve(LT[2],n))),
    L: sublist(L, numberp),
    p: 1,
    if(length(L)>0) then p: lreduce(lcm, map(denom,L)),
    p
)$

/************************* 2 summands RE ****************************************/


allcoeffsBoundFPS(P,x,m,lm):= block([l,i],
     l: [], 
     for i:-lm thru m do (l : endcons(coeff(P,x,i),l)), 
     l
)$

rmffacto(expr):=block([A,ne,de,term],
  ne: num(expr),
  de: denom(expr),
  if(not atom(ne)) then (
    A: args(ne),
    for term in A do
        if(not atom(term)) then
        if(op(term)="!" or op(ne)="!") then ne: subst(expand(term),term,ne)    
  ),
  if(not atom(de)) then (
    A: args(de),
    for term in A do 
        if(not atom(term)) then
        if(op(term)="!" or op(de)="!") then de: subst(expand(term),term,de)
  ),
  ne/de  
)$

substini(j,k,h):=block([s],
    errormsg:false,
    s: errcatch(subst(j,k,h)),
    errormsg:true,
    if length(s)>0 then s[1]
    else 0
)$

kill(Puiseuxnbr)$
RE2FPS(RE, k, z, expr, Puiseuxnbr):= catch(block([f,m,rec,P,N,V,i,j1,T,ini,maxini,minini,hypfs,Eq,h,fps,starti,numh,denh,n1,n2],
    f: expr,
    rec: -first(RE)/last(RE),
    m: length(RE)-1,
    assume(z>0),
    [P,N]: RE2_PolyPart(RE,f,z,k),
    if(not integerp(N)) then (
        V: makelist(concat(A,i),i,0,m-1),
        ratprint:false,
        ini: makelist(ceiling(rhs(linsolve(m*k+i=N,k)[1])),i,0,m-1),
        maxini: lmax(ini),
        hypfs: makelist(V[i+1]*pochfactorsimp(factor(subst(m*k+m*ini[i+1]+i,k,rec)),k)*z^(m*k+m*ini[i+1]+i),i,0,m-1),
        print("The starting point is arbitrary! ", "The requested power series has the following general form"),
        print("where ", T, " is a Laurent polynomial and the Ak are some constants."),
        fps:T + lsum(subst(k,j1,'sum(subst(j1,k,fps),j1,0,inf)),fps,hypfs),
        ratprint:true,
        throw(fps)
    ),
    [P,N]: LPolyPart(subst(z^(1/Puiseuxnbr),z,f),z),
    V: makelist(concat(c,i),i,0,m-1),
    ini: makelist(ceiling(rhs(linsolve(m*k+i=N,k)[1])),i,0,m-1),
    maxini: lmax(ini),
    hypfs: makelist(V[i+1]*pochfactorsimp(factor(subst(m*k+m*ini[i+1]+i,k,rec)),k)*z^(m*k+m*ini[i+1]+i),i,0,m-1),
    Eq:0,
    for i:1 thru m do Eq: Eq + sum(substini(j,k,hypfs[i]),j,0,1),
    Eq: Eq-ratdisrep(taylor(f,z,0,m*maxini+m-1))+P,
    Eq: allcoeffsBound(Eq,z,m*maxini+m-1,-N),
    linsolvewarn: false,
    V: linsolve(sublist(Eq,lambda([v], not constantp(v))),V),
    linsolvewarn: true,
    if(length(%rnum_list)>0) then V:subst(map(lambda([v],v=0),%rnum_list),V),
    hypfs: subst(V, hypfs),
    fps: 0,
/*     P: subst(z^(1/Puiseuxnbr),z,P), */
    for i:1 thru m do (
        h: minfactorial(hypfs[i]),
        errormsg:false,
        if(P#0 and h#0) then (
            starti: 0,
            denh: errcatch(subst(starti-1,k,denom(h))),
            n1: lopow(P,z),
            n2: n1,
            while length(denh)>0 and numh#false and n2>=n1 do (
                denh: denh[1],
                if(denh#0) then (
                    numh: errcatch(subst(starti-1,k,num(h))),
                    if(length(numh)>0) then (
                        numh: numh[1],
                        n2: hipow(numh,z),
                        if(n2>=n1) then (
                            P: P-expand(numh/denh),
                            starti: starti-1,
                            denh: errcatch(subst(starti-1,k,denom(h)))
                        )
                    )
                    else numh: false
                ) else denh:[]
            ),
            h: subst(k+starti,k,h)
        ),
        errormsg:true,
        h: factor(h),
        fps: fps + subst(k,j,sum(subst(j,k,h),j,0,inf))
    ),
    intosum(factor(subst(z^(1/Puiseuxnbr),z,fps))) + P
))$

kill(Hyp,N0)$
FPScombin(RE,a,Hyp,f,P0,N0,p,algo):= catch(block([P,N,fps,THyp,V,j,i,h,hj,neq,Eq,catchEq,minpowj,powj,powEq,C,
subT,xx,m,rlfps,numsubT,densubT,startj,CTHyp,powhj,mmax,n1,n2,fpsn],
    THyp: map(lambda([v],allhypform(v,z,RE,a,algo)),Hyp),
    [P,N]: [P0,N0],
    V: [],
    j:1,
    i:1,
    mmax: 1,
    for h in THyp do(
        T:[],
        for hj in h[2] do(
            V: endcons(concat(c,j),V),
            T: endcons(concat(c,j)*hj,T),
            j: j+1
        ),
        THyp[i]: [h[1],T],
        mmax: lcm(h[1],mmax),
        i: i+1
    ),
    neq: N+mmax*length(V),
    Eq: 0,
    CTHyp: reverse(THyp),
    h: pop(CTHyp),
    errormsg:false,
    for hj in h[2] do(
        powj: hipow(hj,z),
        minpowj: ceiling(rhs(linsolve(powj=N,n)[1])),
        powhj: floor(rhs(linsolve(powj=neq,n)[1])),
/*         catchEq: errcatch(Eq+sum(subst(k,n,hj),k,minpowj,neq+minpowj)), */
        catchEq: errcatch(Eq+sum(subst(k,n,hj),k,minpowj,powhj)),
        while length(catchEq)<1 do (
            minpowj: minpowj+1,
            catchEq: errcatch(Eq+sum(subst(k,n,hj),k,minpowj,powhj))
        ),
        Eq: catchEq[1]
    ),
    errormsg:true,
    powEq: hipow(Eq,z),
    for h in CTHyp do(
        for hj in h[2] do(
            powj: hipow(hj,z),
            minpowj: ceiling(rhs(linsolve(powj=N,n)[1])),
            powhj: floor(rhs(linsolve(powj=neq,n)[1])),
            Eq: Eq+sum(subst(k,n,hj),k,minpowj,powhj)
        ) 
    ),
    Eq: Eq-ratdisrep(taylor(f,z,0,powEq))+P,
    if(algo=ComplexvanHoeij) then Eq: expand(Eq),
    Eq: allcoeffsBound(Eq,z,powEq,-N),
    linsolvewarn: false,
    C: linsolve(sublist(Eq,lambda([v], not constantp(v))),V),
    linsolvewarn: true,
    if(length(C)>0) then (
        if(length(%rnum_list)>0) then C:subst(map(lambda([v],v=0),%rnum_list),C),
        THyp: subst(C,THyp),
        neq: neq+mmax,
        Eq: 0,
        CTHyp: reverse(THyp),
        CTHyp: [],
        for h in THyp do (
            T: sublist(h[2], lambda([v], v#0)),
            if(length(T)>0) then CTHyp: cons([h[1],T],CTHyp)
        ),
        if(length(CTHyp)<1) then (
            if(P-ratdisrep(taylor(f,z,0,neq))=0) then throw(subst(z^(1/p),z,P))
            else throw(false)
        ),
        h: pop(CTHyp),
        errormsg:false,
        for hj in h[2] do(
            powj: hipow(hj,z),
            minpowj: ceiling(rhs(linsolve(powj=N,n)[1])),
            catchEq: errcatch(Eq+sum(subst(k,n,hj),k,minpowj,neq+minpowj)),
            while length(catchEq)<1 do (
                minpowj: minpowj+1,
                catchEq: errcatch(Eq+sum(subst(k,n,hj),k,minpowj,neq+minpowj))
            ),
            Eq: catchEq[1]
        ),
        errormsg:true,
        powEq: hipow(Eq,z),
        for h in CTHyp do(
            for hj in h[2] do(
                powj: hipow(hj,z),
                minpowj: ceiling(rhs(linsolve(powj=N,n)[1])),
                powhj: floor(rhs(linsolve(powj=powEq,n)[1])),
                Eq: Eq+sum(subst(k,n,hj),k,minpowj,powhj)
            ) 
        ),
        Eq: Eq-ratdisrep(taylor(f,z,0,powEq))+P,
        if(algo=ComplexvanHoeij) then Eq: expand(Eq),
        Eq: ratsimp(Eq),
        if(Eq=0) then (
            if(algo=ComplexvanHoeij) then (
                if(not freeof(%i,P) and freeof(%i,ratdisrep(taylor(f,z,0,N-1)))) then (
                    P: realpart(P)
                )
            ),
            P: subst(z^(1/p),z,P),
            fps: 0,
            for h in THyp do(
                T: h[2],
                if(h[1]=1) then (
                    powj: n,
                    subT: map(lambda([v],coeff(v,z,n)),T),
                    subT: factor(lsum(xx,xx,subT)),
                    if(N>0) then (
                        startj: N,
                        densubT: subst(startj-1,n,denom(subT)),
                        while densubT#0 and startj > 0 do (
                            numsubT: subst(startj-1,n,num(subT)*z^(powj/p)),
                            P: P-expand(numsubT/densubT),
                            startj: startj-1,
                            densubT: subst(max(0,startj-1),n,denom(subT))
                        ),
                        powj: subst(n+startj,n,powj),
                        subT: subst(n+startj,n,subT)
                    ),
                    if(subst(0,n,subT)=0 and subT#0) then (
                        startj:1,
                        while subst(startj,n,subT)=0 do (
                            startj: startj+1
                        ),
                        powj: subst(n+startj,n,powj),
                        subT: subst(n+startj,n,subT),
                        factorial_expand:true,
                        subT: xthru(minfactorial(rmffacto(subT))),
                        factorial_expand:false
                    ),
                    n1: lopow(P,z),
                    if(n1<0 and subT#0) then (
                        subT: factcomb(subT),
                        errormsg:false,
                        startj:0,
                        densubT: errcatch(subst(startj-1,n,denom(subT))),
                        n2: subst(startj-1,n,powj/p),
                        numsubT: errcatch(subst(startj-1,n,num(subT)*z^n2)),
                        while length(densubT)>0 and length(numsubT)>0 and n2>=n1 do (
                            numsubT: numsubT[1],
                            densubT: densubT[1],
                            if(n2>=n1 and densubT#0) then (
                                P: P-expand(numsubT/densubT),
                                startj: startj-1,
                                densubT: errcatch(subst(startj-1,n,denom(subT))),
                                n2: subst(startj-1,n,powj/p),
                                numsubT: errcatch(subst(startj-1,n,num(subT)*z^n2))
                            )
                            else densubT: []
                        ),
                        powj: subst(n+startj,n,powj),
                        subT: subst(n+startj,n,subT)
                    ),
                    if(algo=ComplexvanHoeij) then (
                        if(not freeof(%i,subT) and freeof(%i,ratdisrep(taylor(f,z,0,4)))) then (
                            subT: realpart(subT)
                        )
                    ),
                    fpsn: factor(subT)*z^(powj/p),
                    fps: fps + subst(n,j1,sum(subst(j1,n,fpsn),j1,0,inf))
                )
                else(
                    m: h[1],
                    for i:0 thru m-1 do(
                        powj: m*n+i,
                        subT: sublist(T, lambda([v], hipow(v,z)=powj)),
                        subT: map(lambda([v],coeff(v,z,powj)),subT),
                        subT: factor(lsum(xx,xx,subT)),
                        minpowj: floor(N/m),
                        while(subst(minpowj,n,powj)<N) do minpowj: minpowj+1,
                        if(minpowj>0) then (
                            startj: minpowj,
                            densubT: subst(startj-1,n,denom(subT)),
                            while densubT#0 and startj > 0 do (
                                errormsg:false,
                                numsubT: errcatch(subst(startj-1,n,num(subT)*z^(powj/p))),
                                errormsg:true,
                                if(length(numsubT)>0) then ( 
                                    P: P-expand(numsubT[1]/densubT),
                                    startj: startj-1,
                                    densubT: subst(max(0,startj-1),n,denom(subT))
                                )
                                else densubT:0
                            ),
                            powj: subst(n+startj,n,powj),
                            subT: subst(n+startj,n,subT)
                        ),
                        if(subst(0,n,subT)=0 and subT#0) then (
                            startj:1,
                            while subst(startj,n,subT)=0 do (
                                startj: startj+1
                            ),
                            powj: subst(n+startj,n,powj),
                            subT: factor(subst(n+startj,n,subT)),
                            factorial_expand:true,
                            subT: xthru(minfactorial(rmffacto(subT))),
                            factorial_expand:false
                        ),
                        n1: lopow(P,z),
                        if(n1<0 and subT#0) then (
                            subT: factcomb(subT),
                            errormsg:false,
                            startj:0,
                            densubT: errcatch(subst(startj-1,n,denom(subT))),
                            n2: subst(startj-1,n,powj/p),
                            numsubT: errcatch(subst(startj-1,n,num(subT)*z^n2)),
                            while length(densubT)>0 and length(numsubT)>0 and n2>=n1 do (
                                numsubT: numsubT[1],
                                densubT: densubT[1],
                                if(n2>=n1 and densubT#0) then (
                                    P: P-expand(numsubT/densubT),
                                    startj: startj-1,
                                    densubT: errcatch(subst(startj-1,n,denom(subT))),
                                    n2: subst(startj-1,n,powj/p),
                                    numsubT: errcatch(subst(startj-1,n,num(subT)*z^n2))
                                )
                                else densubT: []
                            ),
                            powj: subst(n+startj,n,powj),
                            subT: subst(n+startj,n,subT)
                        ),
                        if(algo=ComplexvanHoeij) then (
                            if(not freeof(%i,subT) and freeof(%i,ratdisrep(taylor(f,z,0,4)))) then (
                                subT: realpart(subT)
                            )
                        ),
                        fpsn: factor(subT)*z^(powj/p),
                        fps: fps + subst(n,j1,sum(subst(j1,n,fpsn),j1,0,inf))
                    )
                )
            ),
            intosum(fps) + P
        )
    )
    else false
))$

zz:Z$
kill(Z)$
Sign(x0):=block([],
    if(sign(x0)=neg) then -1
    else 1
)$

invHypFPS(expr,z,n):=block([RE,a,g,f,j,fps,Term,term,nzc,i,S,pow1,pown,cte,p],
    g: expr,
    f: 1/g,
    RE: FindRE(f,z,a[n]),
    p: funPuiseux([first(lhs(RE)),last(lhs(RE))],n),
    if(p>1) then f: subst(z^p,z,f),
    fps: FPS(f,z,n),
    fps: subst(j,k,fps),
    if(fps#false) then (
        Term: args(intosum(expand(fps))),
        if(length(Term)=4) then (
            if(Term[3]=0) then(
                term: Term[1],
                nzc: 0,
                i:0,
                simpsum:true,
                while nzc=0 do (
                    nzc: subst(i,n,term),
                    i: i+1
                ),
                simpsum:false,
                S: rhs(linsolve(B*nzc=1,B)[1]),
                pow1: hipow(S,z),
                pown: hipow(term,z),
                S: coeff(S,z,pow1),
                term: intosum(-S*subst(k,n,term/z^pown)),
                pown: coeff(expand(pown),n),
                [sum(A[n]*z^((pown*n+pow1)/p),n,0,inf),A[n]=intosum(sum(term*A[n-k],k,1,n)),A[0]=S]
            )
        )
        elseif(length(Term)=2) then 
            if((not freeof(sum, Term[1])) and constantp(Term[2])) then (
                term: args(intosum(Term[1]))[1],
                pown: hipow(term,z),
                term: coeff(term,z,pown),
                if(subst(0,n,pown)=0) then (
                    cte: Term[2],
                    S: rectform(1/(ev(term,n=0,sum)+cte)),
                    term: intosum(-S*subst(k,n,term)),
                    [sum(A[n]*z^(pown/p),n,0,inf),A[n]=intosum(sum(term*A[n-k],k,1,n)),A[0]=S]
               ) 
            )
    )
)$

HypinvFPS(expr,z,n):=catch(block([g1,g2,j],
    g1: num(expr),
    if(g1=1) then throw(invHypFPS(expr,z,n)),
    g2: denom(expr),
    g1: FPS(g1,z,n),
    if(polynomialp(g2,[z]) or polynomialp(g2^2,[z])) then g2: FPS(1/g2,z,n)
    else g2: invHypFPS(1/g2,z,n),
    if(g1#false and g2#false and not(constantp(g1)) and not(constantp(g2))) then (
        g1: subst(j,k,g1),
        g2: subst(j,k,g2),
        if(listp(g2)) then [CauchyProdFPS(g2[1],g1),subst(k,n,g2[2]),g2[3]]
        else CauchyProdFPS(g2,g1)
    )
))$

NLDErecFPS(REi,f,z,n,z0):=catch(block([RE,aterm,n0,n0term,e0,I,rec,P,fps,A,k0,terms,Tsum,T,l,Tnosum,NRE,caterm,mn,tmpsum,evsum,expr,sexpr,addI,i2,Inzeros],
    RE: subst(A,a,REi),
    n0:0,
    terms: args(lhs(RE)),
    Inzeros: sublist(terms, lambda([v], freeof(A,v))),
    if(length(Inzeros)>0) then (
        Inzeros: solve(REi,n),
        if(length(Inzeros)=0) then throw(0)
        else (
            Inzeros: lmax(sublist(map(rhs, Inzeros), integerp)),
            if(integerp(Inzeros)) then throw(taylor(f,z,z0,Inzeros))
            else throw(0)
        )
    ),
    rec: ev(terms,n=n0,sum),
    while(lprod(rec)=0) do (
        n0:n0+1,
        rec: ev(terms,n=n0,sum)
    ),
    aterm: sublist(listofvars(rec),lambda([v], not atom(v))),
    aterm: sort(sublist(aterm, lambda([v], is(equal(A,op(v)))))),
    k0: first(first(aterm)),
    e0: n0-k0,
    terms: subst(n+e0,n,terms),
    RE: subst(n+e0,n,RE),
    Tsum: sublist(terms, lambda([v], not freeof(sum,v))),
    if(length(Tsum)<1) then HolorecFPS(REi,f,z,n,z0,funPuiseux([first(lhs(REi)),last(lhs(REi))],n))
    else(
        /*computation of necessary initial values and cheking whether the expression can be simplified...*/
        n0term: map(lambda([v], if(op(v)="-") then -v else v),Tsum),
        n0term: sublist(n0term,lambda([v],op(v)="*")),
        if(length(n0term)>0) then (
            n0term: map(lambda([v],args(v)[1]),n0term),
            n0term: floor(lmax(n0term))
        )
        else n0term:1,
        T: ratdisrep(taylor(f,z,0,e0)),
        if(polynomialp(T,[z])) then (
            n0term: max(e0,n0term)+1,
            I: makelist(A[j]=coeff(T,z,j),j,0,e0),
            Inzeros: sublist(I, lambda([v], rhs(v)#0)),
            while(length(Inzeros)<1 and e0<=n0term) do (
                e0: e0+1,
                T: ratdisrep(taylor(f,z,k0,e0)),
                I: endcons(A[e0]=coeff(T,z,e0),I),
                if(coeff(T,z,e0)#0) then Inzeros: endcons(coeff(T,z,e0),Inzeros)
            ),          
            if(length(Inzeros)<1) then throw(T)
        )
        else(
            k0: -n0term-n0,
            T: ratdisrep(taylor(f,z,0,k0)),
            while(T=0) do (
                k0:k0+1,
                T: ratdisrep(taylor(f,z,0,k0))
            ),
            NLDEflag: true,
            fps: QNF(z^(-k0)*f,z,n),
            NLDEflag: false,
            fps: subst(z^(n+k0),z^n,fps),
            if(z0=inf or z0=-inf) then throw(subst(Sign(z0)*1/z,z,fps))
            else throw(subst(z-z0,z,fps))
        ),
        n0: 0,
        rec: ev(terms,n=n0,sum),
        rec: subst(I,rec),
        while(length(sublist(rec,lambda([v], v#0)))<0) do (
            n0:n0+1,
            e0:e0+1,
            rec: ev(terms,n=n0,sum),
            T: ratdisrep(taylor(f,z,0,e0)),
            I: endcons(A[e0]=coeff(T,z,e0),I),
            rec: subst(I,rec)
        ),
        RE: subst(n+n0,n,RE),
        fps: sum(A[n]*z^n,n,0,inf),
        if(z0=inf or z0=-inf) then [subst(Sign(z0)*1/z,z,fps),RE,I]
        else [subst(z-z0,z,fps),RE,I]
     )
))$

QDErecFPS(REi,f,z,n,z0):=catch(block([RE,aterm,n0,n0term,e0,I,rec,P,fps,A,k0,terms,Tsum,T,l,Tnosum,NRE,caterm,mn,s,expr,sexpr,addI,i2,Lk,numrec,Inzeros],
    RE: subst(A,a,REi),
    n0:0,
    terms: args(lhs(RE)),
    Inzeros: sublist(terms, lambda([v], freeof(A,v))),
    if(length(Inzeros)>0) then (
        Inzeros: solve(REi,n),
        if(length(Inzeros)=0) then throw(0)
        else (
            Inzeros: lmax(sublist(map(rhs, Inzeros), integerp)),
            if(integerp(Inzeros)) then throw(ratdisrep(taylor(f,z,z0,Inzeros)))
            else throw(0)
        )
    ),
    rec: ev(terms,n=n0,sum),
    while(lprod(rec)=0) do (
        n0:n0+1,
        rec: ev(terms,n=n0,sum)
    ),
    aterm: sublist(listofvars(rec),lambda([v], not atom(v))),
    aterm: sort(sublist(aterm, lambda([v], is(equal(A,op(v)))))),
    k0: first(first(aterm)),
    e0: n0-k0,
    terms: subst(n+e0,n,terms),
    Tsum: sublist(terms, lambda([v], not freeof(sum,v))),
    if(length(Tsum)<1) then HolorecFPS(REi,f,z,n,z0,funPuiseux([first(lhs(REi)),last(lhs(REi))],n))
    else(
        /*computation of necessary initial values and cheking whether the expression can be simplified...*/
        n0term: map(lambda([v], if(op(v)="-") then -v else v),Tsum),
        n0term: sublist(n0term,lambda([v],op(v)="*")),
        if(length(n0term)>0) then (
            n0term: map(lambda([v],args(v)[1]),n0term),
            n0term: floor(lmax(n0term))
        )
        else n0term:1,
        T: ratdisrep(taylor(f,z,0,e0)),
        if(polynomialp(T,[z])) then (
            n0term: max(e0,n0term)+1,
            I: makelist(A[j]=coeff(T,z,j),j,0,e0),
            Inzeros: sublist(I, lambda([v], rhs(v)#0)),
            while(length(Inzeros)<1 and e0<=n0term) do (
                e0: e0+1,
                T: ratdisrep(taylor(f,z,0,e0)),
                I: endcons(A[e0]=coeff(T,z,e0),I),
                if(coeff(T,z,e0)#0) then Inzeros: endcons(coeff(T,z,e0),Inzeros)
            ),          
            if(length(Inzeros)<1) then throw(T)
        )
        else(
            k0: -n0term-n0,
            T: ratdisrep(taylor(f,z,0,k0)),
            while(T=0) do (
                k0:k0+1,
                T: ratdisrep(taylor(f,z,0,k0))
            ),
            fps: QNF(z^(-k0)*f,z,n),
            fps: subst(z^(n+k0),z^n,fps),
            if(z0=inf or z0=-inf) then throw(subst(Sign(z0)*1/z,z,fps))
            else throw(subst(z-z0,z,fps))
        ),
        Tnosum: sublist(terms, lambda([v], freeof(sum,v))),
        Tsum: map(args,map(intosum,Tsum)),
        /*substitution to get the highest order term */
        l:length(I),
        NRE: 0,
        mn:0,    
        while(NRE=0 and mn<l+1) do (
            for s in Tsum do NRE: NRE+subst(s[3]+mn,s[2],s[1])+subst(s[4]-mn,s[2],s[1]),
            NRE: subst(I,NRE),
            mn: mn+1
        ),
        NRE: NRE+lsum(nosum,nosum,Tnosum),
        aterm: sublist(listofvars(NRE),lambda([v], not atom(v))),
        aterm: sort(sublist(aterm, lambda([v], is(equal(A,op(v)))))),
        aterm: last(aterm),
        /* making sure that the highest order term is already taken */
        expr:0,
        for s in Tsum do expr: expr+subst(s[3]+mn,s[2],s[1])+subst(s[4]-mn,s[2],s[1]),
        expr: subst(I,expr),
        while(not freeof(aterm,expr)) do (
            NRE: NRE+expr,
            expr: 0,
            mn: mn+1,
            for s in Tsum do expr: expr+subst(s[3]+mn,s[2],s[1])+subst(s[4]-mn,s[2],s[1]),
            expr: subst(I,expr)
        ),
        addI: sublist(listofvars(NRE), lambda([v], freeof(n,v) and not(atom(v)))),
        addI: length(addI),
        /*e0: e0+addI+mn,*/
        
        Tnsaterm: sublist(listofvars(Tnosum),lambda([v], not atom(v))),
        Tnsaterm: sort(sublist(Tnsaterm, lambda([v], is(equal(A,op(v)))))),
        if(length(Tnsaterm)>0) then (
            Tnsaterm: last(Tnsaterm),
            if(Tnsaterm=aterm) then addI:addI+1
        ),
        
        e0: e0+addI,
        T: ratdisrep(taylor(f,z,0,e0)),
/*      I: append(I,makelist(A[j]=coeff(T,z,j),j,e0-addI-mn+1,e0)), */
        I: append(I,makelist(A[j]=coeff(T,z,j),j,e0-addI+1,e0)),
        NRE: subst(I,NRE),
        /* If it is not possible to get the highest order term, then we necessarily have a polynomial*/
        if(NRE=0) then throw(T),
        
        for s in Tsum do (
            expr: s[1],
            i2: subst(n-mn,n,s[4]),
            sexpr: sum(subst(i,s[2],expr),i,s[3]+mn,i2),
            NRE: NRE + subst(s[2],i,sexpr)
        ),
        
        if(freeof(aterm,NRE)) then (
            aterm: sublist(listofvars(NRE),lambda([v], not atom(v) and not freeof(n,v))),
            aterm: sort(sublist(aterm, lambda([v], is(equal(A,op(v))) and listofvars(first(v))[1]=n))),
            aterm: last(aterm)
        ),
        caterm: factor(coeff(expand(NRE),aterm)),
        NRE: subst(0,aterm,NRE),
        rec: aterm=-NRE/caterm,
        addI: lmax(sublist(map(rhs,solve(caterm,n)),integerp)),
        
        if(addI>=e0) then (
            i2: 1+addI-e0,
            e0: addI+1,
            T: ratdisrep(taylor(f,z,0,e0)),
            I: append(I,makelist(A[j]=coeff(T,z,j),j,e0-i2+1,e0))
        ),
        i0: rhs(linsolve(first(aterm)=e0+1,n)[1]),
        fps: sum(A[n]*z^n,n,0,inf),
        Lk: makelist(concat(k,i)=k,i,1,length(lhs(REi))),
        numrec: sumcontract(intosum(subst(Lk,num(rec)))),
        rec: numrec/denom(rec),
        if(z0=inf or z0=-inf) then [subst(Sign(z0)*1/z,z,fps),subst(n+i0,n,rec),"n>=0",I]
        else [subst(z-z0,z,fps),subst(n+i0,n,rec),"n>=0",I]

     )
))$

HolorecFPS(REi,f,z,n,z0,p):=block([RE,P0,N,aterm,k0,e0,I,laterm,caterm,rec,P,fps,A,Inzeros],
    [P0,N]: LPolyPart(f,z),
    RE: subst(A,a,lhs(REi)),
    aterm: sublist(listofvars(RE), lambda([v], not atom(v))),
    aterm: sort(sublist(aterm, lambda([v], is(equal(A,op(v)))))),
    k0: rhs(linsolve(first(aterm[1]),n)[1]),
    aterm: subst(n+k0,n,aterm),
    RE: subst(n+k0,n,RE),
    laterm: last(aterm),
    caterm: coeff(RE,laterm),
    RE: subst(0,laterm,RE),
    rec: laterm=-RE/caterm,
/*     rec: linsolve(RE, last(aterm))[1], */
    e0: last(first(laterm)),
    P: ratdisrep(taylor(f,z,0,N+e0-1))-P0,
    I: makelist(A[j]=coeff(P,z,j+N),j,0,e0-1),
    rec: subst(n-e0,n,rec),
    fps: P0+sum(A[n]*z^(n+N),n,0,inf),
    fps: subst(z^(1/p),z,fps),
    Inzeros: sublist(I, lambda([v], rhs(v)#0)),
    if(length(Inzeros)=0) then throw(P0),
    if(z0=inf or z0=-inf) then [subst(Sign(z0)*1/z,z,fps),subst(n+length(I),n,rec),"n>=0",I]
    else [subst(z-z0,z,fps),subst(n+length(I),n,rec),"n>=0",I]
)$

cprod(term1,term2,k,n):=block([T1,T2],
    T1: subst(k,n,term1),
    T2: subst(n-k,n,term2),
    sum(sum(factor(T1*T2),k,0,n),n,0,inf)
)$
prodform(A):=block([A0,A1],
    if(length(A)=4 and A[3]=0) then [[A[1]], []]
    else(
        A1:sublist(A, lambda([v], polynomialp(v,[z]))),
        A0:map(lambda([v], first(args(intosum(v)))), sublist(A, lambda([v], not member(v,A1)))),
        [A0,A1]
    )
)$

Copyright():=block([],
    print("Version 1.0"),
    print("Copyright (c) May 2020, Dr. Bertrand Teguia Tabuguia"),
    print("https://www.bertrandteguia.com"),
    print("bertrand.teguia@aims-cameroon.org"),
    print("University of Kassel, Germany")
)$

CauchyProdFPS(fps1,fps2):=block([A1,A2,term1,term2,fps,k,A11,A21,xs],
    A1: args(intosum(expand(fps1))),
    A2: args(intosum(expand(fps2))),
    if(length(A1)=4 and length(A2)=4) then (
        if(A1[3]=0 and A2[3]=0) then (
            A1: subst(j1,k,A1),
            A2: subst(j2,k,A2),
            term1: subst(k,n,first(A1)),
            term2: subst(n-k,n,first(A2)),
            fps: sum(sum(factor(term1*term2),k,0,n),n,0,inf),
            if(freeof(k,hipow(fps,z))) then fps
        )
    )
    else (
        [A1,A11]: prodform(A1),
        [A2,A21]: prodform(A2),
        A11: lsum(xs,xs,A11),
        A21: lsum(xs,xs,A21),
        fps: 0,
        for term1 in A1 do for term2 in A2 do fps: fps+cprod(term1,term2,k,n),
        if(freeof(k,hipow(fps,z))) then intosum(fps + expand(A11*fps2) + expand(A21*fps1)-A11*A21)
    )
)$
simpProdFPS(f1,f2):=block([fps1,fps2],
    fps1: FPS(f1,z,n),
    fps2: FPS(f2,z,n),
    if(fps1#false and fps2#false and not(constantp(fps1)) and not(constantp(fps2))) then CauchyProdFPS(fps1,fps2)
)$

declare(%logconst,constant)$

FPS(expr,z,n,[Z]):=catch(block([z0,f,fps,ConstL],
    ConstL: listofvars(expr),
    if(length(ConstL)>1) then (
        print("You must declare other variables than ", z, " as constants."),
        throw(false)
    ),
    assume(z>0),
    if(emptyp(Z)) then z0: 0
    elseif length(Z)>1 then (
        print("At most 4 arguments needed!"),
        throw(false)
    )
    else (
        z0: Z[1],
        if(not constantp(z0)) then (
            print(z0, "is not a known constant"),
            throw(false)
        )
    ),
    if(not(atom(z) and atom(n)) or constantp(z) or constantp(n)) then (
            print("the second and the third arguments must be atomic variables"),
            throw(false)
    ),
    logexpand:super,
    f: subst(%logconst,log(z),expand(expr)),
    logexpand:true,
    fps: FPSComput(f,z,n,z0),
    subst(log(z),%logconst,fps)
))$

AsymptFPS(f,z,n,z0):=block([l,g,RE,Hyp,a,p,lRE,tRE,s,fps],
    if(z0=inf or z0=-inf) then l: limit(f,z,z0)
    else l: limit(f,z,z0,plus),
    if constantp(l) then (
        if(l#0) then (
            if(z0=inf or z0=-inf) then g: subst(Sign(z0)*1/z,z,f)
            else g: subst(z+z0,z,f),
            RE: FindRE(g,z,a[n]),
            Hyp: HypervanHoeij(RE,a[n],C),
            if(length(Hyp)=1) then (
                if(z0=inf or z0=-inf) then intosum(sum(Sign(z0)*first(Hyp)*l*(1/z)^n,n,0,inf))
                else intosum(sum(first(Hyp)*l*(z-z0)^n,n,0,inf))
            )
            else (
                print("Not computable at", z0),
                f
            )
        )
        else (
            RE: FindRE(f,z,a[n]),
            p: funPuiseux([first(lhs(RE)),last(lhs(RE))],n),
            if(z0=inf or z0=-inf) then l: limit(f*z^(1/p),z,z0)
            else l: limit(f/(z-z0)^(1/p),z,z0,plus),
            if(l#0) then (
                if(z0=inf or z0=-inf) then g: subst(Sign(z0)*1/z^p,z,f)
                else g: subst(z^p+z0,z,f),
                RE: FindRE(g,z,a[n]),
                Hyp: HyperType(RE,a[n],2,1),
                if(length(Hyp)=1 and p=2) then (
                    if(z0=inf or z0=-inf) then intosum(sum(Sign(z0)*first(Hyp)*l*(1/z)^(expand((2*n+1)/p)),n,0,inf))
                    else intosum(sum(first(Hyp)*l*(z-z0)^(n+1/2),n,0,inf))
                )
                else (
                    print("Not computable at", z0),
                    f
                )
            )
        
        )
    )
    else (
        RE: FindRE(f,z,a[n]),
        s: mfoldHyper(RE,a[n]),
        if(length(s)=1) then s: first(first(s))
        else s:1,
        if integerp(s) and s>1 then factor(subst(z^s,z,AsymptFPS(subst(z^(1/s),z,f),z,n,z0)))
        else (
            print("Not computable at", z0),
            f
        )
    )
)$

FPSpowers(f,powp,z,n,z0,p):= catch(block([RE,Hyp,P,N,polflag,mnz,fps,Term,termz,nzc,pow1,C1,coeffz],
    RE: FindRE(f,z,a[n]),
    Hyp: HypervanHoeij(RE,a[n],C),
    if(cardinality(Hyp)>0) then(
        Hyp: [[1,Hyp]],
        [P,N,polflag,mnz]: RE_PolyPart(RE,f,z,a[n]),
        if(mnz > N and P=0) then (
            P: ratdisrep(taylor(f,z,0,N)),
            while(P=0 and N<mnz) do (
                N: N+1,
                P: ratdisrep(taylor(f,z,0,N))
            ),
            P:0
        ),
        if(P=0) then fps: FPScombin(RE,a[n],Hyp,f,0,N,1,ComplexvanHoeij)
        else fps: false,
        if(fps#false) then (
            Term: args(intosum(expand(fps))),
            if(length(Term)=4) then (
                if(Term[3]=0) then(
                    termz: Term[1],
                    nzc: 0,
                    i:0,
                    simpsum:true,
                    while nzc=0 do (
                        nzc: ratsimp(subst(i,n,termz)),
                        i: i+1
                    ),
                    simpsum:false,
                    pow1: hipow(nzc,z),
                    C1: coeff(nzc,z,pow1),
                    if(C1<0) then throw(false),
                    coeffz: subst(1,z,termz),
/*                     coeffz: subst(n-pow1,n,coeffz), */
                    kill(k),
                    coeffz: factor(subst(n-k,n,coeffz)),
                    domain:real,
                    Cn: intosum(sum(((n-k)*powp-k)*coeffz*A[k]/(n*C1),k,0,n-1)),
                    fps: [C1*z^(powp*pow1)+intosum(factor(sum(Cn*z^(n+powp*pow1),n,1,inf))),A[0]=C1^powp],
                    fps: subst(z^(1/p),z,fps),
                    if(z0=inf or z0=-inf) then throw(subst(Sign(z0)*1/z,z,fps))
                    else throw(subst(z-z0,z,fps))
                )
            )
        )
    )
))$

FPStimeout: 10$
FPSmaxterm: 30$

FPSComput(expr,z,n,z0):= catch(block([limitz0,f,a,RE,Cn,algo,p,polflag,P,N,mnz,Hyp,saveRE,THyp,V,j,i,h,hj,neq,Eq,minpowj,powj,powEq,C,fps,t, subT,m,rlfps,DE,g,g1,g2,atomg,minus,Asumfps,listfps,FPSruntime:elapsed_real_time()],
    domain:real,
    if(z0=inf or z0=-inf) then f: subst(Sign(z0)*1/z,z,expr)
    else f: subst(z+z0,z,expr),
    errormsg:false,
    limitz0: -hipow(denom(factor(expr)),z),
    limitz0: errcatch(taylor(f,z,0,limitz0)),
    if(length(limitz0)<1) then (
        if(HolonomicDE(expr,F(z))#false) then throw(AsymptFPS(expr,z,n,z0))
        else (
            print("Not computable at", z0),
            throw(expr)
        )
    ),
    errormsg:true,
    RE: FindRE(f,z,a[n]),
    algo: vanHoeij,
    if(RE#false) then (
        Cn: REcoeff(RE,a[n]),
        if(length(Cn)>1) then p: funPuiseux([first(lhs(RE)),last(lhs(RE))],n)
        else (
            [P,N]: LPolyPart(f,z),
            if(integerp(N)) then throw(ratdisrep(taylor(expr,z,z0,N)))
            else throw(ratdisrep(taylor(expr,z,z0,hipow(P,z))))
        ),
        if(p>1) then (
            f: subst(z^p,z,f),
            RE: FindRE(f,z,a[n]),
            Cn: REcoeff(RE,a[n])
        ),
        if(length(delete(0,Cn))=2) then (
            fps: RE2FPS(Cn,n,z,f,p),
            if(z0=inf or z0=-inf) then throw(subst(Sign(z0)*1/z,z,fps))
            else throw(subst(z-z0,z,fps))  
        ),    
        if(n=j or n=i) then (
            print("Please use another variable of summation (to be corrected soon)"),
            throw(false)
        ),
        [P,N,polflag,mnz]: RE_PolyPart(RE,f,z,a[n]),
        if(polflag and ratsimp(P-ratdisrep(taylor(f,z,0,p+N+length(Cn))))=0) then (
            fps: subst(z^(1/p),z,P),
            if(z0=inf or z0=-inf) then subst(Sign(z0)*1/z,z,fps)
            else subst(z-z0,z,fps) 
        )
        else(
            Hyp: HyperType(RE,a[n]),
            if(length(Hyp)=0) then (
                    f:factor(f),
                    if(op(f)="^") then (
                        g: args(f),
                        if( (numberp(g[2]) and g[2]#2) or (g[2]=2 and op(g[1])="+") ) then (
                            fps: FPSpowers(g[1],g[2],z,n,z0,p),
                            if(fps#false) then throw(fps)
                        )
                    ),
                    saveRE: RE,
                    t:2,
                    while length(Hyp)=0 and t<4 do (
                        RE: FindRE(f,z,a[n],t),
                        if(length(lhs(RE))<FPSmaxterm) then Hyp: HyperType(RE,a[n]),
                        t: t+1
                    ),
                    if(length(Hyp)=0) then (
                        f: expand(f),
                        if(op(f)="+") then (
                            Asumfps: args(f),
                            fps: create_list(FPS(t,z,n),t,Asumfps),
                            listfps: sublist(fps, listp),
                            if(length(listfps)<1 and freeof(false,fps)) then (
                                fps: lsum(t,t,fps),
                                if(z0=inf or z0=-inf) then throw(subst(Sign(z0)*1/z,z,fps))
                                else throw(subst(z-z0,z,fps))
                            )
                        )
                    ),
                    if(length(Hyp)=0) then (
                        RE: saveRE,
                        domain:complex,
                        m1pbranch:true,
                        algo: ComplexvanHoeij,
                        Hyp: HyperType(RE,a[n],algo)
                    )
            ),
            if(length(Hyp)>0) then (
                if(mnz > N and P=0) then (
                    P: ratdisrep(taylor(f,z,0,N)),
                    while(P=0 and N<mnz) do (
                        N: N+1,
                        P: ratdisrep(taylor(f,z,0,N))
                    ),
                    if(polynomialp(P,[z])) then P:0
                    else N:N+1
                ),
                fps: intosum(FPScombin(RE,a[n],Hyp,f,P,N,p,algo)),
                if(fps=false and op(f)="^") then (
                    g: args(f),
                    if( (numberp(g[2]) and g[2]#2) or (g[2]=2 and op(g[1])="+") ) then (
                        fps: FPSpowers(g[1],g[2],z,n,z0,p),
                        if(fps#false) then throw(fps)
                    )
                ),
                if(fps=false and algo=vanHoeij) then (
                    algo: ComplexvanHoeij,
                    Hyp: HyperType(RE,a[n],algo),
                    if(length(Hyp)>0) then fps: intosum(FPScombin(RE,a[n],Hyp,f,P,N,p,algo))
                ),
                if(fps=false) then (
                    f: expand(f),
                    if(op(f)="+") then (
                        Asumfps: args(f),
                        fps: create_list(FPS(t,z,n),t,Asumfps),
                        listfps: sublist(fps, listp),
                        if(length(listfps)<1 and freeof(false,fps)) then (
                            fps: lsum(t,t,fps),
                            if(z0=inf or z0=-inf) then throw(subst(Sign(z0)*1/z,z,fps))
                            else throw(subst(z-z0,z,fps))
                        )
                        else HolorecFPS(RE,f,z,n,z0,p)
                    )
                    
                ),
                if(elapsed_real_time()-FPSruntime>FPStimeout and fps=false) then throw(QNF(expr,z,n,z0)),
                if(fps=false) then (
                    if(op(f)="/" or op(f)="*" or op(f)="-") then (
                        if(op(f)="-") then (
                            f: -f,
                            minus:-1
                        )
                        else minus:1,
                        if(denom(f)=1) then (
                            g: args(f),
                            atomg: minus*lprod(sublist(g,atom)),
                            g: sublist(g,lambda([v],not atom(v))),
                            if(length(g)=2) then (
                                fps: factor(intosum(atomg*simpProdFPS(g[1],g[2]))),
                                if(fps#false) then (
                                    fps: subst(z^(1/p),z,fps),
                                    if(z0=inf or z0=-inf) then subst(Sign(z0)*1/z,z,fps)
                                    else subst(z-z0,z,fps) 
                                )
                                else HolorecFPS(RE,f,z,n,z0,p)
                            )
                            else HolorecFPS(RE,f,z,n,z0,p)
                        )
                        else (
                            fps: minus*HypinvFPS(f,z,n),
                            if(fps#false) then (
                                fps: subst(z^(1/p),z,fps),
                                if(z0=inf or z0=-inf) then subst(Sign(z0)*1/z,z,fps)
                                else subst(z-z0,z,fps)
                            )
                            else HolorecFPS(RE,f,z,n,z0,p)
                            
                        )
                    )
                    elseif(op(f)="^") then (
                        g: args(f),
                        if(g[2]=2) then (
                            fps: simpProdFPS(g[1],g[1]),
                            if(fps#false) then (
                                fps: subst(z^(1/p),z,fps),
                                if(z0=inf or z0=-inf) then subst(Sign(z0)*1/z,z,fps)
                                else subst(z-z0,z,fps) 
                            )
                            else (
                                fps: FPSpowers(g[1],2,z,n,z0,p),
                                if(fps=false) then HolorecFPS(RE,f,z,n,z0,p)
                                else fps
                            )
                        )
                        else HolorecFPS(RE,f,z,n,z0,p)
                    )
                    else HolorecFPS(RE,f,z,n,z0,p)
                )
                else (
                    if(z0=inf or z0=-inf) then subst(Sign(z0)*1/z,z,fps)
                    else subst(z-z0,z,fps)
                )
            )
            else (
                if(op(f)="/" or op(f)="*") then (
                    if(denom(f)=1) then (
                        g: args(f),
                        atomg: lprod(sublist(g,atom)),
                        g: sublist(g,lambda([v],not atom(v))),
                        if(length(g)=2) then (
                            fps: factor(intosum(atomg*simpProdFPS(g[1],g[2]))),
                            if(fps#false) then (
                                fps: subst(z^(1/p),z,fps),
                                if(z0=inf or z0=-inf) then subst(Sign(z0)*1/z,z,fps)
                                else subst(z-z0,z,fps) 
                            )
                            else HolorecFPS(RE,f,z,n,z0,p)
                        )
                        else HolorecFPS(RE,f,z,n,z0,p)
                    )
                    else (
                        fps: HypinvFPS(f,z,n),
                        if(fps#false) then (
                            fps: subst(z^(1/p),z,fps),
                            if(z0=inf or z0=-inf) then subst(Sign(z0)*1/z,z,fps)
                            else subst(z-z0,z,fps)
                        )
                        else HolorecFPS(RE,f,z,n,z0,p)
                    )
                )
                else HolorecFPS(RE,f,z,n,z0,p)
            )
        )
    )
    else(
        if(elapsed_real_time()-FPSruntime>FPStimeout) then throw(QNF(expr,z,n,z0)),
        f:factor(f),
        if(op(f)="^") then (
            g: args(f),
            if( ((numberp(g[2]) and g[2]#2) or (g[2]=2 and op(g[1])="+")) and FindRE(g[1],z,a[n])#false ) then (
                fps: FPSpowers(g[1],g[2],z,n,z0,1),
                if(fps#false) then throw(fps)
            )
        ),
        f: expand(trigsimp(trigexpand(f))),
        if(op(f)="-") then (
            f: -f,
            minus:-1
        )
        else minus:1,
        if(op(f)="*") then (
            g: args(f),
            atomg: minus*lprod(sublist(g,atom)),
            g: sublist(g,lambda([v],not atom(v))),
            if(length(g)=2) then (
                fps: factor(intosum(atomg*simpProdFPS(g[1],g[2]))),
                if(fps#false) then (
                    if(z0=inf or z0=-inf) then subst(Sign(z0)*1/z,z,fps)
                    else subst(z-z0,z,fps) 
                )
            )
        ),
        if(op(f)="/") then (
            DE: HolonomicDE(1/f,F(z)),
            if(DE#false) then (
                fps: invHypFPS(f,z,n),
                if(fps#false) then (
                    fps: [fps[1],A[n]=intosum(minus*rhs(fps[2])),A[0]=minus*rhs(fps[3])],
                    if(z0=inf or z0=-inf) then subst(Sign(z0)*1/z,z,fps)
                    else subst(z-z0,z,fps)  
                )
                else (
                    if(polynomialp(ratdisrep(taylor(f,z,0,QNmax/2)),[z])) then (
                        RE:FPSFindQRE(minus*f,z,a[n]),
                        if(RE#false) then (
                            fps:QDErecFPS(RE,minus*f,z,n,z0),
                            fps
                        )
                    )
                )
            )
            else (
                fps: HypinvFPS(f,z,n),
                if(fps#false) then (
                    if(listp(fps)) then (
                        if(fps[1]#false) then fps: [fps[1],A[k]=intosum(minus*rhs(fps[2])),A[0]=minus*rhs(fps[3])]
                        else (
                            if(ratfunp(ratdisrep(taylor(f,z,0,QNmax/2)),[z])) then (
                                RE:FPSFindQRE(minus*f,z,a[n]),
                                if(RE#false) then (
                                    fps:QDErecFPS(RE,minus*f,z,n,z0),
                                    fps
                                )
                            ) 
                        )
                    )
                    else fps: minus*fps,
                    if(z0=inf or z0=-inf) then subst(Sign(z0)*1/z,z,fps)
                    else subst(z-z0,z,fps)  
                )
                else (
                    if(ratfunp(ratdisrep(taylor(f,z,0,QNmax/2)),[z])) then (
                        RE:FPSFindQRE(minus*f,z,a[n]),
                        if(RE#false) then (
                            fps:QDErecFPS(RE,minus*f,z,n,z0),
                            fps
                        )
                    )
                )
            )
        )
        else (
            if(ratfunp(ratdisrep(taylor(f,z,0,QNmax/2)),[z])) then (
                RE:FPSFindQRE(minus*f,z,a[n]),
                if(RE#false) then (
                    fps:QDErecFPS(RE,minus*f,z,n,z0),
                    fps
                )
            )
        )
        
    )
))$


/* Holonomic Normal form */

HoloRep(expr,z,n,[Z]):=catch(block([RE,ConstL,z0,limitz0,f,a,fps,p,Cn],
    Nmax: 10,
    assume(z>0),
    ConstL: sublist(listofvars(expr), lambda([v], v#z)),
    if(length(ConstL)>0) then (
        print("You must declare each variable in ", ConstL, " as constant."),
        throw(false)
    ),
    domain:real,
    if(emptyp(Z)) then z0: 0
    elseif length(Z)>1 then (
        print("At most 4 arguments needed!"),
        throw(false)
    )
    else (
        z0: Z[1],
        if(not constantp(z0)) then (
            print(z0, "is not a known constant"),
            throw(false)
        )
    ),
    if(not(atom(z) and atom(n)) or constantp(z) or constantp(n)) then (
            print("the second and the third arguments must be atomic variables"),
            throw(false)
    ),
    if(z0=inf or z0=-inf) then f: subst(Sign(z0)*1/z,z,expr)
    else f: subst(z+z0,z,expr),
    errormsg:false,
    limitz0: -hipow(denom(factor(expr)),z),
    limitz0: errcatch(taylor(f,z,0,limitz0)),
    if(length(limitz0)<1) then (
        print("Not analytic at", z0),
        throw(expr)
    ),
    errormsg:true,
    RE: FindRE(f,z,a[n]),
    if(RE#false) then (
        Cn: REcoeff(RE,a[n]),
        if(length(Cn)>1) then p: funPuiseux([first(lhs(RE)),last(lhs(RE))],n)
        else throw(ratdisrep(taylor(expr,z,z0,last(LPolyPart(f,z))))),
        if(p>1) then (
            f: subst(z^p,z,f),
            RE: FindRE(f,z,a[n])
        ),
        Nmax: 6,
        fps: HolorecFPS(RE,f,z,n,z0,p),
        fps
    )
))$

NLDEflag: false$

/* Quadratic Normal form */
QNF(expr,z,n,[Z]):=catch(block([ConstL,z0,limitz0,f,a,RE,fps,n0,Lk],
    assume(z>0),
    ConstL: sublist(listofvars(expr), lambda([v], v#z)),
    if(length(ConstL)>0) then (
        print("You must declare each variable in ", ConstL, " as constant."),
        throw(false)
    ),
    domain:real,
    if(emptyp(Z)) then z0: 0
    elseif length(Z)>1 then (
        print("At most 4 arguments needed!"),
        throw(false)
    )
    else (
        z0: Z[1],
        if(not constantp(z0)) then (
            print(z0, "is not a known constant"),
            throw(false)
        )
    ),
    if(not(atom(z) and atom(n)) or constantp(z) or constantp(n)) then (
            print("the second and the third arguments must be atomic variables"),
            throw(false)
    ),
    if(z0=inf or z0=-inf) then f: subst(Sign(z0)*1/z,z,expr)
    else f: subst(z+z0,z,expr),
    errormsg:false,
    limitz0: -hipow(denom(factor(expr)),z),
    limitz0: errcatch(taylor(f,z,0,limitz0)),
    if(length(limitz0)<1) then (
        print("Not analytic at", z0),
        throw(expr)
    ),
    errormsg:true,
    if(NLDEflag) then RE:FindNLRE(f,z,a[n])
    else RE:FPSFindQRE(f,z,a[n]),
    if(RE#false and ratfunp(ratdisrep(taylor(f,z,0,QNmax/2)),[z])) then (
            if(NLDEflag) then (
                fps:NLDErecFPS(RE,f,z,n,z0),
                NLDEflag:false
            )
            else fps:QDErecFPS(RE,f,z,n,z0),
            fps
    )
))$

/************************************************* Extra work for non-linear DEs **********************************/

Maxqueue(M):=block([queue,j,q],
    queue: makelist(2+i,i,0,M-3),
    queue: endcons(queue[M-2],queue),
    j:M-1,
    while(lsum(q,q,queue)>M) do (
        if(queue[j]>0) then queue[j]:queue[j]-1
        else(
            j: j-1,
            queue[j]: queue[j]-1
        )
    ),
    queue
)$

incrementcode(lead,queue):=block([n,m,M,Mqueue,q,i,j],
    n: lead[1],
    m: n+1,
    M: n+2,
    if(m>=2) then Mqueue: Maxqueue(M),
    if(queue=Mqueue and m>=2) then(
        queue: endcons(M,makelist(0,m-1))
    )
    elseif(queue[m]=M) then (
            lead: lead+1,
            queue: cons(1,makelist(0,m))
    )
    else(
        i:1,
        j:m,
        while(M-lsum(q,q,rest(queue,-i))=queue[j]) do (
            queue[j]:0,
            i:i+1,
            j:j-1
        ),
        queue[j]: queue[j]+1
    ),
    [lead,queue]
)$

ordertocode(n):= block([lead,queue,p],
    lead: [0,1],
    queue: [1],
    p: 0,
    while p < n do (
        [lead,queue]: incrementcode(lead,queue),
        p: p+1
    ),
    [lead,queue]
)$

/** a special non-linear derivative **/

deltadiff(expr,z,n):=block([code,dexpr,j,i,e],
    code: ordertocode(n),
    j:code[1][1],
    dexpr:1,
    for i:1 thru code[1][2] do (
        e: code[2][i],
        dexpr: dexpr*diff(expr,z,j)^e,
        j:j-1
    ),
    dexpr
)$


/* Default maximum order of NL-DEs*/

NLNmax: 30$

/********************************************************* CODE TO FIND NON LINEAR HOLONOMIC DEs *********************************************************/

NLDE(fun,F):=catch(block([f,z,A0,flag,N,I,V,Coef,Eq,Eqs,Sumds,S,D,tmp,polfact,Lflag,isol,R,denCoef],
    algebraic:true,
    f: radcan(trigsimp(trigexpand(fun))),
    algebraic:false,
    z: first(F),
    if(f=0) then F=0
    else(                                                                                                                         /*2*/
        if(NLNmax<30 or integerp(NLNmax)=false) then NLNmax:30,
        flag: false,
        N: 1,
        while N<=NLNmax and flag=false do (    
                I: makelist(i,i,0,N-1),                                                                                                                              
                Coef: create_list(A[i],i,I),
                V: append(Coef,[z]),  
                algebraic:true,                                                                                        
                Eq: expand(num(ratsimp(trigsimp(deltadiff(f,z,N)+sum(Coef[i+1]*deltadiff(f,z,i),i,0,N-1))))),                     /*4*/
                if(Eq=0) then throw(F=0),
                S: args(Eq),
                algebraic:false,
                Sumds: [],
                while S#[] do (                                                                                                     /*5*/
                D: [S[1]],
                tmp: S[1],
                if(length(S)>1) then
                    for j: 2 thru length(S) do
                        if(ratfunp(S[j]/S[1],V)=true) then (
                            tmp: tmp + S[j],
                            D: endcons(S[j], D)
                        ),
                Sumds: endcons(tmp, Sumds),
                S: sublist(S, lambda([v], not(member(v,D))))
                ), 
                isol: sublist(Sumds, lambda([v], lfreeof(Coef,v))),
                if(isol=[]) then(                                                                                                    /*6*/
                Sumds: map(lambda([v],num(factor(v))),Sumds),
                logexpand: all,
                Eqs: [],
                for i: 1 thru length(Sumds) do 
                if(polynomialp(Sumds[i],V)=true or member(Sumds[i],Coef)=true) then Eqs: endcons(Sumds[i],Eqs)                  /*7*/
                else( 
                        factSumd:exp(args(log(Sumds[i]))),
                        polfact: sublist(factSumd, lambda([v], (polynomialp(v,V) or member(v,Coef)) and not(constantp(v)))),
                        Eqs: append(Eqs, polfact)
                ), 
                logexpand:true,
                linsolvewarn:false,
                Eqs: sublist(Eqs, lambda([v], not(polynomialp(v,[z])))), 
                Sol: linsolve(Eqs,Coef),
                linsolvewarn:true, 
                if(Sol#[]) then (        
                    R: map(lambda([v],v=1),%rnum_list),
                    Sol: subst(R,Sol),
                    Coef: map(lambda([v],factor(rhs(v))),Sol),
                    flag: true
                )
                else N: N+1
            )                                                                  
            else N: N+1                                                         
        ),           
        if(N>NLNmax) then flag                                                                                                          /*8*/                                               
        else (
            denCoef: lcm(map(denom, Coef)),
            Coef: map(lambda([v], xthru(denCoef*v)),Coef),
            denCoef*deltadiff(F,z,N)+sum(Coef[i+1]*deltadiff(F,z,i),i,0,N-1)=0
        )   
    )
))$


M: MM$
N: NN$
Mat: Mat1$
k0: k00$
k: kk$
DE1: DE11$
DE2: DE22$
expr: expr1$
Z:zz$
DE:DEDE$
RE:RERE$
f:fexpr$
n:nn$
L:LL$
p:pp$
P:PP$
fun: funf$
F: FF$
Hde_step: Hde_step1$
L1: L11$
L2: L22$
rec1: rec11$
rec2: rec22$
kill(fexpr,nn,LL,RERE,DEDE,pp,zz,xx,PP,DE11,DE22,k00,MM,NN,Mat1,funf,FF,Hde_step1,kk,L11,L22,rec11,rec22)$
